% !TEX root =  main.tex
%
Let $\locset$ be a set of \emph{localities} and $\asort$ range over
basic sorts which include $\asort[int]$, $\asort[bool]$,
$\asort[str]$, etc.
%
The set $\tupleset$ of \emph{(tuple) types} consists of the terms
derived from the following grammar:
\begin{eqnarray*}
  \atuple & \bnfdef & \asort \bnfmid
                      x : \asort \bnfmid
                      x  \bnfmid
                      \nu \aloc \bnfmid
                      \aloc \bnfmid
                      \atuple \cdot \atuple \bnfmid
                      \wildcard
\end{eqnarray*}
Names $x : \asort$ and $\nu \aloc$ act as binders for the names $x$
and $\aloc$ at type level.
%
We say that $\atuple$ \emph{generates} when in one of its fields there
is a $\nu \aloc$ type.
%
Tuple types \emph{match} according to the relation
$\matches \subseteq \tupleset \times \tupleset$ defined as
\eMnote{add typing env}
\[
  \atuple \matches \atuple' \iff
  \begin{cases}
    \atuple = \atuple'  
    & 
    \text{if $\atuple\in\{\asort, x : \asort, x, \nu \aloc, \aloc\}$}
    \\
    \atuple_1 \matches \atuple'_1
    \land \atuple_2 \matches \atuple'_2
    &
    \text{if } \atuple = \atuple_1 \cdot \atuple_2
    \text{ and }  \atuple' = \atuple'_1 \cdot \atuple'_2
    \\
    \atuple = \wildcard \vee \atuple' = \wildcard & \text{otherwise}
  \end{cases}
\]

%We define
%\[
%  \atuple \clashes \atuple' \iff \exists \atuple'' \qst \atuple'' \matches \atuple \land \atuple'' \matches \atuple'
%\]
%
%and say that $\atuple$ and $\atuple'$ \emph{are in conflict} when
%$\atuple \clashes \atuple'$.

We fix two disjoint sets $\participants = \{\ptp p, \ptp q, \ldots\}$
and $\multiroles = \{\amulti P, \amulti Q, \ldots \}$, respectively of
\emph{participants} and \emph{multiple} roles, and define the set of
\emph{roles}
$\roleset = \participants \cup \multiroles \cup
\multiroles^\unknownstarop \cup \multiroles^\unknownop$ (ranged over
by $\arole, \arole_1, \ldots$) where
$\multiroles^{\unknownstarop} = \{\unknownstar \sst \amulti P
\in\multiroles\}$ and
$\multiroles^{\unknownop} = \{ \unknown \sst \amulti p \in \multiroles
\}$ account for some flexibility when implementing multiroles: an
action involving a $\unknownstar$ role can be optionally executed by
an implementation of role $\amulti P$, while $\unknown$ establishes
that exactly one implementer must execute that action.
%
We conventionally write multiroles with initial uppercase letter and
unique roles with initial lowercase letter.
%
We write $\eqR$ for the least equivalence relation on $\roleset$
satisfying
\[\amulti P \eqR \unknownstar \hspace{2cm} \amulti P \eqR \unknown\]

Roles are to be thought of as types inhabited by instances of
processes enacting the behaviour specified in a choreography.
%
Participants are unit types while multiroles account for multiple
instances of processes all performing actions according to their role.

Global types $\aK$ have the following syntax
%\eMnote{non e' chiaro se vogliamo $\aK \parop \aK $}
\begin{eqnarray*}
  \aK & \bnfdef & \asum \bnfmid
%                  \aK \parop \aK \bnfmid
                  X \bnfmid
                  \arec
  \\[1.5em]
  \apref & \bnfdef & \apref[\arole] \bnfmid
                     \apref[\arole][{}][@][@][.] \bnfmid
                     \apref[{}][\arole] \bnfmid
                     \apref[{}][\arole][@][@][.]
  \\[1em]
        & \bnfmid & \apref[\arole][\arole'] \bnfmid
                    \apref[\arole][\arole'][@][\aloc][.]
\end{eqnarray*}
where $I$ is a finite set of indexes and $\aloc \in \locset$ is a
locality.
%
We write $\nil$ for $\asum$ when $I = \emptyset$ and
$\apref_j.\aK_j$ instead of $\asum$ when $I = \{j\}$.
%
We omit trailing occurrences of $\nil$.

We syntactically distinguish two kinds of prefixes $\apref$.
%
The prefixes generated by the first four productions in the grammar of
$\apref$ above are the \emph{autonomous} prefixes, that is those
prefixes that processes can execute directly on a tuple space without
coordinating with other processes; the prefixes generated by the
remaining two productions of the grammar are the \emph{interaction}
prefixes, namely those involving more roles.
%
We define $\roles \apref$ to the set of roles in $\apref$; note that
$\roles \apref$ is a singleton if, and only if, $\apref$ is an
autonomous prefix.
%
Likewise, $\roles \aK \subseteq \participants \cup \multiroles$ is the
set of roles in $\aK$.


\begin{example}[Auction]

\[
  \begin{array}{l}
  \apref[\ptp {broker}][\amulti {Seller}][{\atuple[makeOffer]}][{\aloc[s]}][.].
  \\  	
  \apref[\amulti {Seller}][\amulti {Buyer}][{{\asort[str]} \cdot {\asort[int]} \cdot {\nu \aloc}}][{\aloc[c]}][.].
  \\
  \arec[@][\left({
    	\begin{array}{l}
	\apref[][\amulti {Buyer}][{i:{\asort[str]} \cdot p:{\asort[int]} \cdot \aloc[o]}][{\aloc[c]}][].
	\\
	\apref[\amulti {Buyer}][\amulti {Buyer}][{i \cdot {\asort[booked]}}][{\aloc[c]}][.].
	\\
	\arec[Y][\left({
    	\begin{array}{l}
	\apref[\amulti {Buyer}][\amulti {Seller}][{i \cdot {\asort[offer]} \cdot {\asort[int]}}][{\aloc[o]}][.].
	\\
	\apref[][\amulti {Seller}][{i \cdot \asort[offer]} \cdot  {\asort[int]}][{\aloc[o]}][].
	\\
	\qquad 
	\apref[\amulti {Seller}][\amulti {Buyer}][{i \cdot \asort[sold]}][{\aloc[c]}][.].
	\\
	\qquad\apref[][\amulti {Buyer}][i \cdot {\asort[booked]}][{\aloc[c]}][].
	X
	\\
	\qquad
	+
	\\
	\qquad
	\apref[\amulti {Seller}][\amulti {Buyer}][{i \cdot {\asort[request]}  \cdot \asort[int]}][{\aloc[o]}][.]. 
	\\
	\qquad
	\apref[][\amulti {Buyer}][i \cdot {\asort[request]} \cdot {\asort[int]}][{\aloc[o]}][].
	\\
	\qquad\qquad	
	Y
	\\
	\qquad\qquad	
	+
	\\ 
	\qquad\qquad\apref[][\amulti {Buyer}][i \cdot {\asort[booked]}][{\aloc[c]}][].
	\\
	\qquad\qquad
	\apref[\amulti {Buyer}][\amulti {Seller}][{i\cdot {\asort[quit]}}][{\aloc[o]}][.]. 
	\\
	\qquad\qquad
	\apref[\amulti {Seller}][\amulti {Buyer}][{i \cdot p \cdot {\nu \aloc}}][{\aloc[c]}][.].X
	\\
	\qquad
	+
	\\
	\qquad
	\apref[\amulti {Seller}][\amulti {Buyer}][{i\cdot {\asort[refused]}}][{\aloc[o]}][.]. 
	\\
	\qquad
	\apref[\amulti {Seller}][\amulti {Buyer}][{i \cdot p \cdot {\nu \aloc}}][{\aloc[c]}][.].
	\\
	\qquad
	\apref[][\amulti {Buyer}][{i \cdot \asort[refused]}][{\aloc[o]}][].
	\\
	\qquad\apref[][\amulti {Buyer}][i \cdot {\asort[booked]}][{\aloc[c]}][].
	X
	\end{array}
	}\right)]
	\\
	+
	\\
	\apref[][\amulti {Buyer}][{{\asort[str]} \cdot {\asort[booked]}}][{\aloc[c]}][.]. 
	X
	\\
	+
	\\
	\apref[][\amulti {Buyer}][{{\asort[str]} \cdot {\asort[sold]}}][{\aloc[c]}][.]. 
	X
	\\
	+
	\\
	\nil
  	\end{array}
  }\right)]
  \\
  \end{array}
\]
\finex
\end{example}

\eMnote{un'alternativa}
\begin{example}[Auction]
\[
  \begin{array}{l}
    \apref[\ptp {broker}][\amulti {Seller}][{\atuple[makeOffer]}][{\aloc[s]}][.].
    \\  	
    \arec[X][\left({
    \begin{array}{l}
      \apref[\amulti{Seller}][\amulti {Buyer}][s:{\asort[seller]} \cdot {i:{\asort[str]} \cdot p:{\asort[int]}}][{\aloc[m]}].
      \\\qquad
      X
      \\
      \chop
      \\
      \apref[\amulti {Buyer}][\amulti {Seller}][s \cdot i \cdot {\asort[offer]} \cdot \nu \aloc][{\aloc[m]}][.].
      \\\qquad
      \arec[Y][\left({
      \begin{array}{l}
	\apref[\amulti {Seller}][\amulti {Buyer}][{\asort[quit]}][\aloc].
	\\\qquad
	\apref[\amulti {Seller}][][s \cdot i \cdot p][{\aloc[m]}].
        \\
        \qquad
        X
        \\
        \chop
	\\
        \apref[\amulti{Seller}][\amulti {Buyer}][{\asort[sold]}][\aloc].
        \\\qquad
        \apref[\amulti{Seller}][\ptp{broker}][s \cdot i \cdot \aloc \cdot {\asort[fee]}][{\aloc[s]}].        
        \\
        \qquad
        X
	\\
        \chop
	\\
        \apref[\amulti {Seller}][\amulti {Buyer}][{\asort[more]}][\aloc].
        \\
        \qquad\apref[\amulti {Buyer}][\amulti {Seller}][{\asort[offer]}][{\aloc}][].
	\\
        \qquad	
	Y
      \end{array}
      } \right)]
    \end{array}
    }\right)]
    \\
  \end{array}
\]
\finex
\end{example}

TBC: 

Well-formedness (TBC): Besides the usual conditions about single selector and knowledge of 
choices,  we assume the following conditions hold in any $\aK$.

\begin{itemize}
% \item $\roles {\aK_1} \cap \roles {\aK_2} = \emptyset$ if $\aK = \aK_1 \parop \aK_2$
\item $\neg (\arole \eqR \arole')$ in $\apref[\arole][\arole']$ and
  $\apref[\arole][\arole'][@][\aloc][.]$.
  %
  \todo[inline]{eM: does the restriction above apply only to branches? May be it can be relaxed under the new semantic interpretation...}
\item the prefixes of each branch must generate
  \todo[inline]{eM: may be not}
\end{itemize}
%
\todo[inline]{eM:
  To ensure uniquess of selector in choices we can syntactically restrict the branching operator as
  \[
    \asum[@][@][{\apref[\arole][\arole'_i][\atuple_i]}]
  \]
  A simple way to ensure knowledge of choice is to require that the
  first input actions of passive roles in the branches are
  ``disjoint'' (ie non matching tuples or different locations).
  %
  This is just for simplicity as we could adopt definitions similar
  to the ones in \cite{gt16,gt17}.
  %
  % The notion of well formedness seems to guarantee a much weaker
  % notion of correctness than the usual ones.
  % %
  % Firstly, note that well-formedness here does not imply deadlock
  % freedom (but this is fine since we are not interested in properties
  % of the control of processes).
  % %
  A problem to consider is that, even assuming unique selector, many
  instances of the selector role could exercise choices concurrently.
  %
  This may create confusion if different branches generate matching
  tuples on the a locality.
  %
  % A example could be the following:
  \[
    K_\mathrm{bad} = \apref[A][B][int].K_1 \chop \apref[A][B][str].K_2
  \]
  \[
    K_1 = \apref[B][C][str].\apref[C][B][bool]
  \]
  \[
    K_2 = \apref[B][C][bool]
  \]
  This type of confusion does not seem to introduce deadlocks, but may
  alter the intended data flow (in the example above the instance of
  $C$ executing $K_2$ branch may receive the boolean that the instance
  of $C$ in $K_1$ generates for $B$).
  %
  We can tackle this issue in two different way (at least): one way is
  to statically ensure that tuples generated on one branch do not
  match any other on another branch; another way is to modify the
  semantics of the choice by implicitly inserting an extra field in
  each tuple with a unique identifier of each branch.
  %
  \newline
  %
  Under the current interpretation of our semantics, probably the
  notion of correctness we can guarantee is that any set of instances
  taking a choice will fully execute a branch.
  %
}

Local types $\aL$ have the following syntax
\begin{eqnarray*}
  \aL & \bnfdef & %\nil \bnfmid
                  \aout[].\aL \bnfmid
                  \ain[].\aL \bnfmid
                  \ard[].\aL \bnfmid
                  %\aL \chop \aL \bnfmid
                  \aLsum \bnfmid
                  X \bnfmid
                  \arec[@][\aL]
\end{eqnarray*}
As for global types, we write $\nil$ for a sum with an empty set $I$ of branches. 

For a local type $\aL = \aLsum$, we write $\selectors \aL$ for the selecting roles the choice, i.e.,
$\selectors \aL = \cup_{i\in I}{\{\arole_i\}}$.
%
Moreover, we assume
\begin{itemize}
\item $\aL_i \neq\aLsum[j][J]$, for all $i \in I$.
\item $\arole_i \eqR \arole_j$ for all $i,j \in I$.
\end{itemize}

The projection $\proj$ of a global type $\aK$ on a role
$\arole \in \participants \cup \multiroles$ is defined as
\[
  \proj =
  \begin{cases}
    \nil & \text{if } \arole \not \in \roles \aK
    \\
    (\proj[\aK_1]) \ + \ (\proj[\aK_2])
    &
    \text{if } \aK = \aK_1 \ + \ \aK_2
    \\
    \arole_1 : \aout[].(\proj[\aK_1])
    &
    \text{if } \arole \eqR \arole_1\ \text{ and }\ \aK = \apref[\arole_1].\aK_1
    \\
    \arole_1 : \ain[].(\proj[\aK_1])
    &
    \text{if } \arole \eqR \arole_1\ \text{ and }\ \aK = \apref[{}][\arole_1].\aK_1 \ \text{ and }
    \\
    \arole_1 : \ard[].(\proj[\aK_1])
    &
    \text{if } \arole \eqR \arole_1\ \text{ and }\ \aK = \apref[{}][\arole_1][@][@][.].\aK_1
    \\
    \arole_1 : \aout[].(\proj[\aK_1])
    &
    \text{if } \arole \eqR \arole_1\ \text{ and either}\ \aK = \apref[\arole_1][\arole_2].\aK_1
    \\
    &
    \hspace{2.5cm}\text{ or }\ \aK = \apref[\arole_1][\arole_2][@][\aloc][.].\aK_1
    \\
    \arole_2 : \ain[].(\proj[\aK_1])
    &
    \text{if } \arole \eqR \arole_2\ \text{ and }\ \aK = \apref[\arole_1][\arole_2].\aK_1
    \\
    \arole_2 : \ard[].(\proj[\aK_1])
    &
    \text{if } \arole \eqR \arole_2\ \text{ and }\ \aK = \apref[\arole_1][\arole_2][@][\aloc][.].\aK_1
    \\
    \proj[\aK_1]
    &
    \text{if } \aK = \apref.\aK_1 \text{ and the previous ones do not apply}
%    \\
%    \proj[\aK_1]   
%    & \text{if } \aK = \aK_1 \parop \aK_2 
%    \text{ and } \arole \not\eqR \roles {\aK_2}
   \\
   X
   & \text{if } \aK = X
   \\
   \arec[@][{(\proj[\aK_1])}]
   &
   \text{if } \aK = \arec[@][\aK_1]
  \end{cases}
\]


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
