% !TEX root =  main.tex
%
Let $\locset$ be a set of \emph{localities} and $\asort$ range over
basic sorts which include $\asort[int]$, $\asort[bool]$,
$\asort[str]$, etc.
%
Tuple types have the following syntax:
\begin{eqnarray*}
  \atuple & \bnfdef & \asort \bnfmid
                      x : \asort \bnfmid
                      x  \bnfmid
                      \nu \aloc \bnfmid
                      \aloc \bnfmid
                      \atuple \cdot \atuple \bnfmid
                      \wildcard \bnfmid
\end{eqnarray*}
Names $x : \asort$ and $\nu \aloc$ act as binders for the names $x$ and $\aloc$ at type level. 
%
Tuple types \emph{match} according to the relation $\_ \matches \_$
defined as
\[
  \atuple \matches \atuple' \iff
  \begin{cases}
    \atuple = \atuple'  
    & 
    \text{if $\atuple\in\{\asort, x : \asort, x, \nu \aloc, \aloc\}$}
    \\
    \atuple_1 \matches \atuple'_1
    \land \atuple_2 \matches \atuple'_2
    &
    \text{if } \atuple = \atuple_1 \cdot \atuple_2
    \text{ and }  \atuple' = \atuple'_1 \cdot \atuple'_2
    \\
    \atuple = \wildcard \vee \atuple' = \wildcard & \text{otherwise}
  \end{cases}
\]

%We define
%\[
%  \atuple \clashes \atuple' \iff \exists \atuple'' \qst \atuple'' \matches \atuple \land \atuple'' \matches \atuple'
%\]
%
%and say that $\atuple$ and $\atuple'$ \emph{are in conflict} when
%$\atuple \clashes \atuple'$.

We fix two disjoint sets $\participants = \{\ptp p, \ptp q, \ldots\}$
and $\multiroles = \{\amulti P, \amulti Q, \ldots \}$, respectively of
\emph{participants} and \emph{multiple} roles, and define the set of
\emph{roles} $\roleset = \participants \cup \multiroles \cup
\{\unknownstar, \unknown\ |\ \amulti P \in\multiroles\}$ (ranged over by
$\arole, \arole_1, \ldots$) where $\unknownstar$ and $\unknown$ are
`wildcards' accounting for some flexibility when implementing
multiroles: an action involving a $\unknownstar$ role can be
optionally executed by an implementation of role $\amulti P$, while
$\unknown$ establishes that exactly one implementor must execute that
action.
%
We conventionally write multiroles with initial uppercase letter and
unique roles with initial lowercase letter.
%
We write $\eqR$ for the least equivalence relation on $\roleset$
satisfying
\[\amulti P \eqR \unknownstar \hspace{2cm} \amulti P \eqR \unknown\]



Global types $\aK$ have the following syntax
%\eMnote{non e' chiaro se vogliamo $\aK \parop \aK $}
\begin{eqnarray*}
  \aK & \bnfdef & \asum \bnfmid
%                  \aK \parop \aK \bnfmid
                  X \bnfmid
                  \arec
  \\
  \apref & \bnfdef & \apref[\arole] \bnfmid
                         \apref[{}][\arole] \bnfmid
                         \apref[{}][\arole][@][@][.] \bnfmid
                         \apref[\arole][\arole'] \bnfmid
                         \apref[\arole][\arole'][@][\aloc][.]
\end{eqnarray*}
where $I$ is a finite set of indexes and $\aloc \in \locset$ is a
locality.
%
We write $\nil$ for $\asum$ when $I = \emptyset$ and
$\apref_j.\aK_j$ instead of $\asum$ when $I = \{j\}$.
%
We omit trailing occurrences of $\nil$.
 

\begin{example}[Auction]

\[
  \begin{array}{l}
  \apref[\ptp {broker}][\amulti {Seller}][{\atuple[makeOffer]}][{\aloc[s]}][.].
  \\  	
  \apref[\amulti {Seller}][\amulti {Buyer}][{{\asort[str]} \cdot {\asort[int]} \cdot {\nu \aloc}}][{\aloc[c]}][.].
  \\
  \arec[@][\left({
    	\begin{array}{l}
	\apref[][\amulti {Buyer}][{i:{\asort[str]} \cdot p:{\asort[int]} \cdot \aloc[o]}][{\aloc[c]}][].
	\\
	\apref[\amulti {Buyer}][\amulti {Buyer}][{i \cdot {\asort[booked]}}][{\aloc[c]}][.].
	\\
	\arec[Y][\left({
    	\begin{array}{l}
	\apref[\amulti {Buyer}][\amulti {Seller}][{i \cdot {\asort[offer]} \cdot {\asort[int]}}][{\aloc[o]}][.].
	\\
	\apref[][\amulti {Seller}][{i \cdot \asort[offer]} \cdot  {\asort[int]}][{\aloc[o]}][].
	\\
	\qquad 
	\apref[\amulti {Seller}][\amulti {Buyer}][{i \cdot \asort[sold]}][{\aloc[c]}][.].
	\\
	\qquad\apref[][\amulti {Buyer}][i \cdot {\asort[booked]}][{\aloc[c]}][].
	X
	\\
	\qquad
	+
	\\
	\qquad
	\apref[\amulti {Seller}][\amulti {Buyer}][{i \cdot {\asort[request]}  \cdot \asort[int]}][{\aloc[o]}][.]. 
	\\
	\qquad
	\apref[][\amulti {Buyer}][i \cdot {\asort[request]} \cdot {\asort[int]}][{\aloc[o]}][].
	\\
	\qquad\qquad	
	Y
	\\
	\qquad\qquad	
	+
	\\ 
	\qquad\qquad\apref[][\amulti {Buyer}][i \cdot {\asort[booked]}][{\aloc[c]}][].
	\\
	\qquad\qquad
	\apref[\amulti {Buyer}][\amulti {Seller}][{i\cdot {\asort[quit]}}][{\aloc[o]}][.]. 
	\\
	\qquad\qquad
	\apref[\amulti {Seller}][\amulti {Buyer}][{i \cdot p \cdot {\nu \aloc}}][{\aloc[c]}][.].X
	\\
	\qquad
	+
	\\
	\qquad
	\apref[\amulti {Seller}][\amulti {Buyer}][{i\cdot {\asort[refused]}}][{\aloc[o]}][.]. 
	\\
	\qquad
	\apref[\amulti {Seller}][\amulti {Buyer}][{i \cdot p \cdot {\nu \aloc}}][{\aloc[c]}][.].
	\\
	\qquad
	\apref[][\amulti {Buyer}][{i \cdot \asort[refused]}][{\aloc[o]}][].
	\\
	\qquad\apref[][\amulti {Buyer}][i \cdot {\asort[booked]}][{\aloc[c]}][].
	X
	\end{array}
	}\right)]
	\\
	+
	\\
	\apref[][\amulti {Buyer}][{{\asort[str]} \cdot {\asort[booked]}}][{\aloc[c]}][.]. 
	X
	\\
	+
	\\
	\apref[][\amulti {Buyer}][{{\asort[str]} \cdot {\asort[sold]}}][{\aloc[c]}][.]. 
	X
	\\
	+
	\\
	\nil
  	\end{array}
  }\right)]
  \\
  \end{array}
\]
\finex
\end{example}

\eMnote{un'alternativa}
\begin{example}[Auction]
\[
  \begin{array}{l}
    \apref[\ptp {broker}][\amulti {Seller}][{\atuple[makeOffer]}][{\aloc[s]}][.].
    \\  	
    \arec[Z][\left({
    \begin{array}{l}
      \apref[\amulti{Seller}][\amulti {Buyer}][s:{\asort[seller]} \cdot {i:{\asort[str]} \cdot p:{\asort[int]}}][{\aloc[m]}].
      \\
      \apref[\amulti {Buyer}][\amulti {Buyer}][{s \cdot i \cdot p}][{\aloc[m]}][.].
      \\\qquad
      Z
      \\
      \chop
      \\
      \apref[\amulti {Buyer}][\amulti {Seller}][s \cdot i \cdot {\asort[offer]} \cdot \nu \aloc][{\aloc[m]}][.].
      \\\qquad
      \arec[Y][\left({
      \begin{array}{l}
	\apref[\amulti {Seller}][\amulti {Buyer}][{\asort[quit]}][\aloc].
	\\\qquad
	\apref[\amulti {Seller}][][s \cdot i \cdot p][{\aloc[m]}].
        \\
        \qquad
        Z
        \\
        \chop
	\\
        \apref[\amulti{Seller}][\amulti {Buyer}][{\asort[sold]}][\aloc].
        \\
        \qquad
        Z
	\\
	\qquad
        \chop
	\\
        \apref[\amulti {Seller}][\amulti {Buyer}][{\asort[more]}][\aloc].
        \\
        \qquad\apref[\amulti {Buyer}][\amulti {Seller}][{\asort[offer]}][{\aloc}][].
	\\
        \qquad	
	Y
      \end{array}
      } \right)]
    \end{array}
    }\right)]
    \\
  \end{array}
\]
\finex
\end{example}

We write $\roles \aK \subseteq \participants \cup \multiroles$ for the set of roles in $\aK$. 
TBC: 

Well-formedness (TBC): Besides the usual conditions about single selector and knowledge of 
choices,  we assume the following conditions hold in any $\aK$.

\begin{itemize}
%	\item $\roles {\aK_1} \cap \roles {\aK_2} = \emptyset$ if $\aK = \aK_1 \parop \aK_2$
	\item $\neg (\arole \eqR \arole')$ in $\apref[\arole][\arole']$ and $\apref[\arole][\arole'][@][\aloc][.]$.
	\item 
\end{itemize}



Local types $\aL$ have the following syntax
\begin{eqnarray*}
  \aL & \bnfdef & %\nil \bnfmid
                  \aout[].\aL \bnfmid
                  \ain[].\aL \bnfmid
                  \ard[].\aL \bnfmid
                  %\aL \chop \aL \bnfmid
                  \aLsum \bnfmid
                  X \bnfmid
                  \arec[@][\aL]
\end{eqnarray*}
As for global types, we write $\nil$ for a sum with an empty set $I$ of branches. 

For a local type $\aL = \aLsum$, we write $\selectors \aL$ for the selecting roles the choice, i.e.,
$\selectors \aL = \cup_{i\in I}{\{\arole_i\}}$.
%
Moreover, we assume
\begin{itemize}
\item $\aL_i \neq\aLsum[j][J]$, for all $i \in I$.
\item $\arole_i \eqR \arole_j$ for all $i,j \in I$.
\end{itemize}

The projection $\proj$ of a global type $\aK$ on a role $\arole \in \participants \cup \multiroles$ is
defined as
\[
  \proj =
  \begin{cases}
    \nil   
    & \text{if } 
        \arole \not \in \roles \aK  
    \\
    \proj[\aK_1] +\ \proj[\aK_2]   
    & \text{if } 
        \aK = \aK_1 +\  \aK_2  
    \\
    \arole_1 : \aout[].\proj[\aK_1]   
    & \text{if } 
        \arole \eqR \arole_1\  \text{ and }\ \aK = \apref[\arole_1].\aK_1  
    \\
    \arole_1 : \ain[].\proj[\aK_1]
    & \text{if } 
      	\arole \eqR \arole_1\  \text{ and }\ \aK = \apref[{}][\arole_1].\aK_1  \ \text{ and }
    \\
    \arole_1 : \ard[].\proj[\aK_1]
    & \text{if } 
    	\arole \eqR \arole_1\  \text{ and }\ \aK = \apref[{}][\arole_1][@][@][.].\aK_1
    \\
    \arole_1 : \aout[].\proj[\aK_1]   
    & \text{if } 
    \arole \eqR \arole_1\  \text{ and either}\  
    \aK = \apref[\arole_1][\arole_2].\aK_1 
    \\ & \hspace{2.5cm}\text{ or }\ \aK = \apref[\arole_1][\arole_2][@][\aloc][.].\aK_1
     \\
    \arole_2 : \ain[].\proj[\aK_1]   
    & \text{if } 
    \arole \eqR \arole_2\  \text{ and }\  
    \aK = \apref[\arole_1][\arole_2].\aK_1
    \\
    \arole_2 : \ard[].\proj[\aK_1]   
    & \text{if } 
    \arole \eqR \arole_2\  \text{ and }\  
    \aK = \apref[\arole_1][\arole_2][@][\aloc][.].\aK_1
    \\
    \proj[\aK_1]   
    & \text{if } \aK = \apref.\aK_1
    \text{ and the previous ones do not apply}
%    \\
%    \proj[\aK_1]   
%    & \text{if } \aK = \aK_1 \parop \aK_2 
%    \text{ and } \arole \not\eqR \roles {\aK_2}
   \\
    X & \text{if } \aK = X \\
    \arec[@][{\proj[\aK_1]}] & \text{if } \aK = \arec[@][\aK_1]
  \end{cases}
\]


\input{semanticslocal}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
