% !TEX root =  main.tex

We give semantics to global types using \emph{partially-ordered
  multi-sets} (pomsets for short).
%
Following~\cite{gaifman1987partial}, a \emph{pomset} is an isomorphism
class of labelled partially-ordered sets (lposet) where, fixed a set
of labels $\lset$,
\begin{itemize}
\item an lposet is a triple $(\eset, \leq, \alf)$, with $\eset$ a set
  of events, $\leq$ is a partial order on $\eset$, and
  $\alf: \eset \rightarrow \lset$ a labelling function mapping events
  in $\eset$ to labels in $\lset$;
\item two lposets $(\eset, \leq, \alf)$ and $(\eset', \leq', \alf')$
  are \emph{isomorphic} if there is a bijection
  $\phi: \eset \rightarrow \eset'$ such that
  $\ae \leq \ae' \iff \phi(\ae) \leq' \phi(\ae')$ and
  $\alf = \alf' \circ \phi$.
\end{itemize}
%
Intuitively, the partial order $\leq$ yields a causality relation
among events; for $\ae \neq \ae'$, if $\ae \leq \ae'$ then $\ae'$ is
caused by $\ae$ or, in other words, the occurrence of $\ae'$ must be
preceded by the one of $\ae$ in any execution respecting the order
$\leq$.
%
Note that $\alf$ is not required to be injective: for
$\ae \neq \ae' \in \eset$, $\alf(\ae) = \alf(\ae')$ means that $\ae$
and $\ae'$ model different occurrences of the same action.
%
In the following, $[\eset, \leq, \alf]$ denotes the isomorphism class
of $(\eset, \leq, \alf)$, symbols $\apom,\apom', \dots$ (resp.
$\aR, \aR', \dots$) range over (resp. sets of) pomsets, and we assume
that pomset $\apom$ contains at least one lposet which will possibly
be referred to as $(\esetof \apom$, $\leqof \apom, \alfof \apom)$.
%
The empty pomset is denoted as $\emptypom$.

An event $\ae$ is an \emph{immediate predecessor} of an event $\ae'$
(or equivalently $\ae'$ is an \emph{immediate successor} of $\ae$) in
a pomset $\apom$ if $\ae \neq \ae'$, $\ae \leqof \apom \ae'$, and for
all $\ae'' \in \esetof \apom$ such that
$\ae \leqof \apom \ae'' \leqof \apom \ae'$ either $\ae = \ae''$ or
$\ae' = \ae''$.
%
We will represent pomsets as (a variant\footnote{Edges of Hasse
  diagrams are usually not oriented; here we use arrows so to draw
  order relations between events also horizontally.} of) Hasse
diagrams of the immediate predecessor relation; for instance, the
pomset
%\todo{{RB: anche $(\ae_1,\ae_5)$ nel pomset (non nelle figure ovviamente)?}}
\[
  \left[\{\ae_1,\ae_2,\ae_3,\ae_4,\ae_5\}, \{(\ae_1,\ae_2),(\ae_1,\ae_3),
    (\ae_1,\ae_4), (\ae_1,\ae_5), (\ae_4,\ae_5)\},
    \alf% :
    % \begin{cases}
    %   \ae_1 \mapsto \apref[\ptp p][]
    %   \\
    %   \ae_2,\ae_3 \mapsto \apref[][{\amulti q}]
    %   \\
    %   \ae_4 \mapsto \apref[\amulti R][][@][@][.]
    %   \\
    %   \ae_5 \mapsto \apref[][\amulti R][@][@][.]
    % \end{cases}
  \right]
\]
is more conveniently written as
\[
  \pomsetrep{
    \node (out) {$\ae_1$};
    \node[below left = of out] (in1) {$\ae_2$};
    \node[below right = of out] (in2) {$\ae_3$};
    \node[above right = of in2] (out2) {$\ae_4$};
    \node[below = of out2] (in3) {$\ae_5$};
    \draw[->] (out) -- (in1);
    \draw[->] (out) -- (in2);
    \draw[->] (out) -- (out2);
    \draw[->] (out2) -- (in3);
  }[\alf][][node distance = .5cm and .3cm]
  \qquad\text{or}\qquad
  \pomsetrep{
    \node (out) {$\alf(\ae_1)$}; % {$\apref[{\ptp p}][]$};
    \node[below left = of out] (in1) {$\alf(\ae_2)$}; % {$\apref[][{\amulti q}]$};
    \node[below right = of out] (in2) {$\alf(\ae_3)$}; % {$\apref[][{\amulti q}]$};
    \node[above right = of in2] (out2) {$\alf(\ae_4)$}; % {$\apref[\amulti R][][@][@][.]$};
    \node[below = of out2] (in3) {$\alf(\ae_5)$}; % {$\apref[][\amulti R][@][@][.]$};
    \draw[->] (out) -- (in1);
    \draw[->] (out) -- (in2);
    \draw[->] (out) -- (out2);
    \draw[->] (out2) -- (in3);
  }[][][node distance = .5cm and .1cm]
\]

  

% Given an autonomous prefix $\apref$, we let $\pomsetsingle$ to be
% the pomset with a single event labelled by $\apref$.
%
%We will use the auxiliary operations on pomsets described below.
%
% Define the (disjoint) union of two pomsets $\apom$ and $\apom'$ as
% \[
%   \apom \pomsetcup \apom' =
%   [\esetof{\apom} \uplus \esetof{\apom'},
%   \leqof{\apom} \uplus \leqof{\apom'},
%   \alfof{\apom} \uplus \alfof{\apom'}]
% \]


In the definition of our semantics we follow a principle that
distinguishes the nature of autonomous and interaction prefixes.
\begin{itemize}
\item A tuple type $\atuple$ generated by an autonomous output can
  be accessed by any instance of \emph{any} other role.
  %
  However, there is no obligation to access the tuple $\atuple$, hence
  our semantics has to contemplate the cases where no read or input of
  $\atuple$ happens.
\item Interactions are slightly more subtle.
  %
  Firstly, a tuple type $\atuple$ in an read-only interaction is meant
  to be eventually accessed by (an instance of) the receiving role.
  %
  Secondly, the tuple type $\atuple$ of a consuming interaction must
  be eventually consumed by an instance of the receiving role.
  %
  Thirdly, if $\atuple$ is in a consuming interaction any instance of
  the receiving role is allowed to read $\atuple$.
\end{itemize}

To capture this semantics we label events with 
autonomous prefixes $\apref$, possibly decorated as $\alabel$.
%
Intuitively, e.g., a label $\alabel[@][][\arole][@][@][.]$
(resp. $\alabel[@][\arole][][@][@][.]$) represents the fact that the
$i^\mathit{th}$ instance of $\arole$ reads (resp. produces) a tuple of
type $\atuple$.
%
Labels $\apref$ not prefixed with $[\_]$ simply specify that the event
can be performed by any instance of the role in $\apref$.
% 
Hereafter, we only deal with pomsets labelled  as  above.
%
\todo{eM: qui}
%
%
% Finally, for $h \geq 1$ and a pomset $\apom$ we define
% \[
%   \apom^h =
%   \begin{cases}
%     r & \text{if } h = 1
%     \\
%     r \pomsetcup r^{h-1} & \text{if } h > 1
%   \end{cases}
% \]
% The operation $\_^h$ extends element-wise to sets of pomsets.
%
%
Also, we assign \emph{basic pomsets} $\bp$ to prefixes $\apref$, a
basic pomset yields the causal relations of $\apref$ imposed by the
design principle described above.
% 
For an autonomous prefix $\apref[@][@][][]$ we define
$\bp = \left\{ \pomsetrep{\node {$\alabel$}}[] \right\}$.
%
For interaction prefixes we define
%
\begin{align*}
  \bp[@][{\apref[\arole][\arole'][@][@][.]}] =
  &
    \bigcup_{h \geq 1}
    \left\{
    \pomsetrep{
    \node (out) {$\alabel[@][\arole][][\arole' \cdot \atuple][@][.]$};
    \node[below left = of out] (rd1) {$\ae_1$};
    \node[below = of out] (dots) {};
    \node[below right = of out] (rd2) {$\ae_h$};
    \draw[->] (out) -- (rd1);
    \draw[->] (out) -- (rd2);
    \draw[dotted] (rd1) -- (rd2);
    }[\alf][][node distance = 1cm and -.25cm]\right\}
  \\
  \bp[@][{\apref[\arole][\arole']}] =
  &
    \bigcup_{h \geq 1}\left\{
    \pomsetrep{
    \node (out) {$\alabel[@][\arole][][\arole' \cdot \atuple]$};
    \node[below left = of out] (rd1) {$\ae_1$};
    \node[below = of out] (dots) {};
    \node[below right = of out] (rd2) {$\ae_h$};
    \node[below = of dots] (in) {$\alabel[@][][\arole'][\arole' \cdot \eraseB\atuple]$};
    \draw[->] (out) -- (rd1);
    \draw[->] (out) -- (rd2);
    \draw[->] (rd1) -- (in);
    \draw[->] (rd2) -- (in);
    \draw[dotted] (rd1) -- (rd2);
    }[\alf][][node distance = 1cm and -.25cm]\right\}
    \cup
    \left\{
    \pomsetrep{
    \node (out) {$\alabel[@][\arole][][\arole' \cdot \atuple']$};
    \node[below = of out] (in) {$\alabel[@][][\arole'][\arole' \cdot \eraseB\atuple]$};
    \draw[->] (out) -- (in);
    }[]
    \right\}
\end{align*}
where each read-only event $\ae_j$ (with $1 \leq j \leq h$) is labelled as  
$\alf (\ae_j) = \apref[][\arole'][\arole' \cdot \eraseB\atuple][@][.]$  
%
%$: {\big(\ae_j \mapsto \apref[][\arole'][\arole' \cdot \atuple][@][.]\big)_{1 \leq j \leq h}}$
%
with 
$\eraseB\atuple$ the binder-free version of $\atuple$. 
Formally, $\eraseB{\_}$ is defined  such that 
$\eraseB{(\nu x:\asort)} = x : \asort$,  it is the identity on $\asort$, $\wildcard$ and $x : \asort$ and it behaves 
homomorphically over $\_\cdot\_$. 
%
Note that the tuples in the labels of the events are \quo{prefixed} by the 
role $\arole'$ meant to access  them; this requires to extend $\asort$ so to
include  $\roleset$.



We can now give the semantics of prefixes as follows
\begin{align*}
  \ksem{\apref} =
  &
    \begin{cases}
      \bp[1][\apref]
      & \text{if $\apref$ autonomous } \land \roles{\apref} \subseteq \participants
      \\
      \bigcup_{i \geq 1}\bp[@][\apref]
      % \bigcup_{h \geq 1}\big\{\pomsetrep{
      % \node {$\alabel[1]\cdots\alabel[h]$};
      % }[]\big\},
      & \text{if $\apref$ autonomous } \land \roles{\apref} \not\subseteq \participants
    \end{cases}
%  \qquad \text{if $\apref$ autonomous}
  \\
  \ksem{\apref[\arole][\arole'][@][@][.]} =
  &
    \begin{cases}
      \bp[1][{\apref[\arole][\arole'][@][@][.]}]
      & \text{if } \arole \in \participants
      \\
      \bigcup_{i \geq 1}\bp[@][{\apref[\arole][\arole'][@][@][.]}]
      & \text{otherwise}
    \end{cases}
  \\
  \ksem{\apref[\arole][\arole']} =
  &
    \begin{cases}
      \bp[1][{\apref[\arole][\arole']}]
      & \text{if } \arole \in \participants
      \\
      \bigcup_{i \geq 1}\big(\bp[@][{\apref[\arole][\arole']}]\big)
      & \text{otherwise}
    \end{cases}
\end{align*}

As customary in other
choreographic approaches~\cite{},  the semantics of (closed) global types
considers only  \emph{well-formed} global
types, namely those enjoying \emph{well-sequencedness} and
\emph{well-branchedness}.
%
With respect to standard notions, however, these concepts have some
peculiarities which we now discuss.

%
% 
%\eMnote{{quando $\leq = \leqof{\apom} \uplus \leqof{\apom'}$ abbiamo il parallelo}}
%
% Finally, for $h \geq 1$ and a pomset $\apom$ we define
% \[
%   \apom^h =
%   \begin{cases}
%     r & \text{if } h = 1
%     \\
%     r \pomsetcup r^{h-1} & \text{if } h > 1
%   \end{cases}
% \]
% The operation $\_^h$ extends element-wise to sets of pomsets.

\bigskip

The key points of well-sequencedness are highlighted in 
the following type
\begin{align}\label{eq:seq}
  \apref[\arole_1][\arole_2][{\asort[str] \cdot \wildcard}][\aloc] \seqop
  \apref[\arole_2][\arole_3][{\asort[str] \cdot \asort[int]}][\aloc]
\end{align}
%
where an instance of $\arole_2$ transforms a pair generated by
$\arole_1$ into a pair for $\arole_3$.
%
The choreography \eqref{eq:seq} may be violated when
$\arole_1$ generates a tuple of type $\asort[str] \cdot \asort[int]$.
%
In fact, such a tuple could match the type consumed by $\arole_3$ and
therefore $\arole_3$ could \quo{steal} the tuple from $\arole_2$.
%
The problem is due to the fact that the tuples are generated on the same location and they match each other.
%
More generally, the problem arises when different interactions introduce races on tuple types. Formally, write $(\atuple, \aloc) \in \aK$ when there is a
prefix in $\aK$ whose tuple type is $\atuple$ and whose location is
$\aloc$; we say that $(\atuple, \aloc)$ is \emph{local} to $\aK$ if
either of the following holds:
\begin{itemize}
\item $\aK = \asum[@][@][][]$ and there is $i \in I$ such that either
  $(\atuple, \aloc)$ is local to $\aK_i$ or $\apref_i$ outputs
  $\atuple$ at $\aloc$, there is $\atuple'$ in an input from
  $\aloc$ in $\aK$,
\todo{RB: $\aK_i$?}
 and $\atuple \matches \atuple'$
\item $\aK = \aK_1 \seqop \aK_2$ and either $(\atuple, \aloc)$ is local to
  $\aK_1$ or   $(\atuple, \aloc)$ is local to $\aK_2$
\item $\aK = \grec[@][@][\aK']$ and $(\atuple, \aloc)$ is local to
  $\aK'$.
% \todo{AC+RB: sintassi della ricorsione cambiata? A cosa serve $\aK'$?}
\end{itemize}
%
Our notion of well-sequencedness requires that there are no races
on tuple types: a choreography $\aK_1 \seqop \aK_2$ is
\emph{conflict-free} if for $i \neq j \in \{1,2\}$
%
\begin{itemize}
\item for all $(\atuple,\aloc)$ local to $\aK_i$ and for all
  $(\atuple', \aloc) \in \aK_j$, $\atuple \matches \atuple'$ implies
  $(\atuple', \aloc)$ is in a read-only prefix in $\aK_j$
\item for all $(\atuple,\aloc)$ in an autonomous input prefix of $\aK_i$ and for all $(\atuple', \aloc)$ in an
  output prefix of $\aK_j$, $\atuple \matches \atuple'$ implies
  $(\atuple',\aloc)$ is in a consuming
\todo{RB: togliere ``consuming''? (la terminologia \`e cambiata)}
 output prefix in $\aK_j$.
\end{itemize}
% such that $\atuple_i$ occurs in a prefix of $\aK_i$ both at a
% locality $\aloc$, \eMnote{Problema: $\aloc$ vs $\alocvar$}

We introduce the auxiliary operation $\rseq[][]$ that sequentially
composes pomsets.
%
The sequential composition of $\apom$ and $\apom'$ has to make the
actions of a role in $\apom$ to precede its actions in $\apom'$ and
to make
autonomous outputs in $\apom$ to precede autonomous
matching accesses in $\apom'$.
% \quo{copy} of $\apom'$ with every maximal event of $\apom$.
%
Formally, an \emph{unmatched output of a pomset $\apom$} is an
event $\ae \in \esetof \apom$ such that $\alfof \apom(\ae)$ is an
output with tuple type $\atuple$ and for all $\ae'$ successors of
$\ae$ in $\apom$, if $\alfof{\apom}(\ae')$ is an input with tuple type
$\atuple'$ then $\atuple \matches \atuple' = \textit{undef}$;
similarly, call \emph{unmatched input of $\apom$} an event
$\ae \in \esetof \apom$ such that $\alfof \apom(\ae)$ is an output
with tuple type $\atuple$ and for all $\ae' \leqof \apom \ae$ in
$\apom$, if $\alfof \apom (\ae')$ is an input with tuple type
$\atuple'$ then $\atuple \matches \atuple' = \textit{undef}$.
%
% for each $\ae \in \max \apom$, let
% $\apom'_{\ae} = [\{\ae\} \times \eset_{\apom'}, \leq, \alf]$ where
% $(\ae,\ae_1) \leq (\ae,\ae_2) \iff \ae_1 \leqof{\apom'} \ae_2$ and
% $\alfof{\apom'_{\ae}} = (\ae,\ae') \mapsto \alfof{\apom'}(\ae')$ for
% all $\ae' \in \esetof{\apom'}$.
% %
% Observe that $\apom'_{\ae}$ is isomorphic to $\apom'$, and
Let $\apom$ and $\apom'$ such that
$\esetof \apom \cap \esetof{\apom'} = \emptyset$,
recall that the
labels of events are autonomous prefixes for which $\roles{}$ is a
singleton,
%
\todo{AC: dove \`e scritto?}
%
and define
\[
  \rseq[\apom][\apom'] = 
  \bigcup_{\scriptsize
    \begin{array}{c}
      \ae \text{ unmatched output of $\atuple$},
      \\
      \ae' \text{ unmatched input of $\atuple'$},
      \\
      \atuple \matches \atuple'
    \end{array}
  } \big\{
  [\esetof{\apom} \uplus \esetof{\apom'},
  \leq_{\ae,\ae'},
  \alfof{\apom} \uplus \alfof{\apom'}]
  \big\}
\]
where $\leq_{\ae,\ae'}$ is the reflexo-transitive closure of
$\leqof{\apom} \cup \leqof{\apom'} \cup \{(e,e')\}$.
%
Finally,
\begin{align*}
  \ksem{\aK_1 \seqop \aK_2} =
  &
    \begin{cases}
      \rseq[\ksem{\aK_1}][\ksem{\aK_2}] & \text{if } \ws[\aK_1][\aK_2]
      \\
      \mathit{undef} & \text{otherwise}
    \end{cases}
\end{align*}
where the well-sequencedness condition $\ws[\aK_1][\aK_2]$ holds when
$\aK_1 \seqop \aK_2$ is conflict-free and any unit role $\ptp a$
performing actions in $\aK_2$ acts in $\aK_1$ as well and all the
first actions of $\ptp a$ in $\aK_2$ causally depend on all last
actions of $\ptp a$ in $\aK_1$ in each pomset in
$\rseq[\ksem{\aK_1}][{\ksem{\aK_2}}]$.

\bigskip

% To avoid this problem we introduce \emph{run-time} tuples
We now consider well-branchedness, the other condition of
well-formedness.
%
As usual, well-branchedness requires two conditions: single selector
and knowledge of choices.
%
This can be formalised by requiring that one process in the choice is
\emph{active}, namely it selects the branch to take, while the others
are \emph{passive}, namely they are informed of the chosen branch by
inputting some information that unambiguously identifies each branch
of the choice.
%
We syntactically\footnote{
%
  This is just for simplicity as we could adopt definitions similar to
  the ones in \cite{gt16,gt17} at the cost of higher technical
  complexity.
%
} enforce uniqueness of selectors; a choice with several branches,
takes the form
\begin{align}
  \asum\label{eq:ch}
\end{align}
namely the instance of $\arole$ acts as \emph{unique} selectors.
%
Intuitively, a passive instance (for example one enacting role
$\arole_i$) in \eqref{eq:ch} has to be able to ascertain which branch
the selector decided when the choice was taken.
%
A simple way to ensure this is to require that the first input actions
of each passive roles are pairwise \quo{disjoint} (\ie\ non matching
tuples or different locations) among branches.
%
% This is just for simplicity as we could adopt more general
% definitions similar to the one based on divergence points in
% \cite{gt16,gt17}.

The conditions on active and passive processes alone are not enough:
in our framework, the notion of well-branchedness is slightly
complicated by the presence of multiple roles.
%
For instance, even assuming unique selectors, many instances of a
selector role could exercise choices concurrently.
%
This may create confusion if different branches generate matching
tuples on a locality as illustrated by next example.
\begin{example}\label{ex:nonwb}
  Let
  \begin{align*}
    \aK_\mathrm{bad} = & \apref[\amulti A][\amulti B][{\asort[int]}][\aloc] \mkop{.} K_1 \chop \apref[\amulti A][\amulti B][{\asort[str]}][\aloc] \mkop{.} K_2
    \\
    \aK_1 = & \apref[\amulti B][\amulti C][{\asort[str]}][\aloc] \mkop{.} \apref[\amulti C][\amulti B][{\asort[bool]}][\aloc]
    \\
    \aK_2 = & \apref[\amulti B][\amulti C][{\asort[bool]}][\aloc]
  \end{align*}
  In $\aK_\mathrm{bad}$ confusion may arise that may alter the
  intended data flow when two groups of instances of $\amulti A$,
  $\amulti B$, and $\amulti C$ execute the choice so that each group
  takes a different branch.
  %
  In fact, the instance of $\amulti C$ executing $K_2$ in the second
  branch may receive the boolean that the instance of $\amulti C$ in
  $K_1$ executing the first branch generates for $\amulti B$.
  %
  \eMnote{This type of confusion does not seem to introduce deadlocks}
  %
  \finex
\end{example}
%
Therefore we require that tuple types in different branches of a
choice do not match when they are at the same locality and that if a
branch of a choice involves a unit role then none of the branches of
the choice involves multiple roles.
%
This condition, dubbed \emph{confusion-free branching} ensures that
different \quo{groups} of instances involved in concurrent resolutions
of a choice do not \quo{interfere} with each other. If a unit role is involved,
only one group can resolve the choice. 
%
We remark that the above condition is not a limitation; in fact, we
can pre-process branches of choices by adding an extra field in all
tuples of the branch so to unequivocally identify on which branch the
tuple type is used.

To sum up, a choice as in~\eqref{eq:ch} is \emph{well-branched},
written $\wb[{\big\{\bigcup_{i \in I}\apref_i\mkop{.}\aK_i\big\}}]$,
when it is confusion-free, there is a unique active role, all other
roles are passive.
%
So we define
%
\begin{align*}
  % 
  \ksem{\asum[@][@][][]} =
  &
    \begin{cases}
      \{ \emptypom \} & \text{if } I = \emptyset
      \\
      \bigcup_{\apom \in \ksem{\apref_i},\apom' \in \ksem{\aK_i}} \rseq[\apom][\apom']
      & 
      \text{if } \wb[{\big\{\bigcup_{i \in I}\apref_i\mkop{.}\aK_i\big\}}]
      \\
      \mathit{undef} & \text{otherwise}
    \end{cases}
  \\
\end{align*}

\bigskip



  %
% The notion of well formedness seems to guarantee a much weaker
% notion of correctness than the usual ones.
% %
% Firstly, note that well-formedness here does not imply deadlock
% freedom (but this is fine since we are not interested in properties
% of the control of processes).
% %
%
% A example could be the following:
%
%
\eMnote{We can tackle this issue in two different way (at least): one way is
to statically ensure that tuples generated on one branch do not match
any other tuple on another branch; another way is to modify the
semantics of the choice by implicitly inserting an extra field in each
tuple with a unique identifier of each branch.
\\
Under the current interpretation of our semantics, probably the notion
of correctness we can guarantee is that any set of instances taking a
choice will fully execute a branch.
}

\bigskip

Finally, the semantic equation for the recursive global type $\grec$
require some auxiliary functions:
\begin{align*}
  \mathit{STOP}(\arole, \aK, \seq y) = & \apref[\arole][\arole_1][{\asort[stop]}][y_1] \seqop \ldots \seqop \apref[\arole][\arole_n][{\asort[stop]}][y_n]
  \\
  \mathit{LOOP}(\arole, \aK, \seq y, \seq y') = & \apref[\arole][\arole_1][{\nu y'_1:\asort[loc]}][y_1)] \seqop \ldots \seqop \apref[\arole][\arole_n][{\nu y'_n:\asort[loc]}][y_n]
\end{align*}
where $\roles \aK = \{\arole, \arole_1, \ldots, \arole_n\}$ with
$\arole \not\in \{\arole_1, \ldots, \arole_n\}$ and
$\seq y = y_1 \cdots y_n$ and 
$\seq y' = y'_1 \cdots y'_n$.
%
Then, we define
\begin{align*}
  \ksem{\grec} =
  &
    \begin{cases}
      \bigcup_{h \geq 0} \ksem{\unfold h \grec {\fn{\aK}} {\seq y}  {\seq y'}} & \text{if } \ws[\aK\sust X \nil][\aK\sust X \nil]
      \\ & \text{ and } \seq y \cap \fn{\aK} = \emptyset
      \\
      \mathit{undef} & \text{otherwise}
    \end{cases}
\end{align*}
where
\[
  \unfold h \grec L {\seq y} {\seq y'} =
  \begin{cases}
    \mathit{STOP}(\arole,\seq y) & \text{if } h = 0
    \\
    \mathit{LOOP}(\arole,\aK, \seq y, \seq y') \seqop \aK \sust X {\aK'} & \text{otherwise}
  \end{cases}
\]
%
where $\aK' = \unfold{h-1}{\grec}{L \cup \seq y \cup \seq y'}{\seq y'}{\seq y''}$
with $\seq y''$ fresh.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
