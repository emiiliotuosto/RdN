We give semantics to global types using \emph{partially-ordered
  multi-set} (pomsets for short).
%
Following~\cite{gaifman1987partial}, a \emph{pomset} is an isomorphism
class of labelled partially-ordered sets (lposet) where, fixed a set
of labels $\lset$,
\begin{itemize}
\item an lposet is a triple $(\eset, \leq, \alf)$, with $\eset$ a set
  of events, $\leq$ is a partial order on $\eset$, and
  $\alf: \eset \rightarrow \lset$ a labelling function mapping events
  in $\eset$ to labels in $\lset$;
\item two lposets $(\eset, \leq, \alf)$ and $(\eset', \leq', \alf')$
  are \emph{isomorphic} if there is a bijection
  $\phi: \eset \rightarrow \eset'$ such that
  $\ae \leq \ae' \iff \phi(\ae) \leq' \phi(\ae')$ and
  $\alf = \alf' \circ \phi$.
\end{itemize}
%
Intuitively, the partial order $\leq$ yields a causality relation
among events; for $\ae \neq \ae'$, if $\ae \leq \ae'$ then $\ae'$ is
caused by $\ae$ or, in other words, the occurrence of $\ae'$ must be
preceded by the one of $\ae$ in any execution respecting the order
$\leq$.
%
Note that $\alf$ is not required to be injective: for
$\ae \neq \ae' \in \eset$, $\alf(\ae) = \alf(\ae')$ means that $\ae$
and $\ae'$ model different occurrences of the same action.
%
In the following, $[\eset, \leq, \alf]$ denotes the isomorphism class
of $(\eset, \leq, \alf)$, symbols $\apom,\apom', \dots$ (resp.
$\aR, \aR', \dots$) range over (resp. sets of) pomsets, and we assume
that pomsets $\apom$ contain at least one lposet which will possibly
be referred to as $(\esetof \apom$, $\leqof \apom, \alfof \apom)$.
%
The empty pomset is denoted as $\emptypom$.

An event $\ae$ is an \emph{immediate predecessor} of an event $\ae'$
(or equivalently $\ae'$ is an \emph{immediate successor} of $\ae$) in
a pomset $\apom$ if $\ae \neq \ae'$, $\ae \leqof \apom \ae'$, and for
all $\ae'' \in \esetof \apom$ such that
$\ae \leqof \apom \ae'' \leqof \apom \ae'$ either $\ae = \ae''$ or
$\ae' = \ae''$.
%
We will represent pomsets as (a variant\footnote{Edges of Hasse
  diagrams are usually not oriented; here we use arrows so to draw
  order relations between events also horizontally.} of) Hasse
diagrams of the immediate predecessor relation; for instance, the
pomset
\[
  \left[\{\ae_1,\ae_2,\ae_3,\ae_4\}, \{(\ae_1,\ae_2),(\ae_1,\ae_3),
    (\ae_1,\ae_4), (\ae_4,\ae_5)\},
    \alf% :
    % \begin{cases}
    %   \ae_1 \mapsto \apref[\ptp p][]
    %   \\
    %   \ae_2,\ae_3 \mapsto \apref[][{\amulti q}]
    %   \\
    %   \ae_4 \mapsto \apref[\amulti R][][@][@][.]
    %   \\
    %   \ae_5 \mapsto \apref[][\amulti R][@][@][.]
    % \end{cases}
  \right]
\]
is more conveniently written as
\[
  \pomsetrep{
    \node (out) {$\ae_1$};
    \node[below left = of out] (in1) {$\ae_2$};
    \node[below right = of out] (in2) {$\ae_3$};
    \node[above right = of in2] (out2) {$\ae_4$};
    \node[below = of out2] (in3) {$\ae_5$};
    \draw[->] (out) -- (in1);
    \draw[->] (out) -- (in2);
    \draw[->] (out) -- (out2);
    \draw[->] (out2) -- (in3);
  }[\alf][][node distance = .5cm and .3cm]
  \qquad\text{or}\qquad
  \pomsetrep{
    \node (out) {$\alf(\ae_1)$}; % {$\apref[{\ptp p}][]$};
    \node[below left = of out] (in1) {$\alf(\ae_2)$}; % {$\apref[][{\amulti q}]$};
    \node[below right = of out] (in2) {$\alf(\ae_3)$}; % {$\apref[][{\amulti q}]$};
    \node[above right = of in2] (out2) {$\alf(\ae_4)$}; % {$\apref[\amulti R][][@][@][.]$};
    \node[below = of out2] (in3) {$\alf(\ae_5)$}; % {$\apref[][\amulti R][@][@][.]$};
    \draw[->] (out) -- (in1);
    \draw[->] (out) -- (in2);
    \draw[->] (out) -- (out2);
    \draw[->] (out2) -- (in3);
  }[][][node distance = .5cm and .1cm]
\]
  
% Given an autonomous prefix $\apref$, we let $\pomsetsingle$ to be
% the pomset with a single event labelled by $\apref$.
%
We will use the auxiliary operations on pomsets described below.
%
Define the (disjoint) union of two pomsets $\apom$ and $\apom'$ as
\[
  \apom \pomsetcup \apom' =
  [\esetof{\apom} \uplus \esetof{\apom'},
  \leqof{\apom} \uplus \leqof{\apom'},
  \alfof{\apom} \uplus \alfof{\apom'}]
\]
The sequential composition of $\apom$ and $\apom'$ composes an
instance of $\apom'$ with every maximal event of $\apom$.
%
Formally, for each $\ae \in \max \apom$, let
$\apom'_{\ae} = [\{\ae\} \times \eset_{\apom'}, \leq, \alf]$ where
$(\ae,\ae_1) \leq (\ae,\ae_2) \iff \ae_1 \leqof{\apom'} \ae_2$ and
$\alfof{\apom'_{\ae}} = (\ae,\ae') \mapsto \alfof{\apom'}(\ae')$ for
all $\ae' \in \esetof{\apom'}$.
%
Observe that $\apom'_{\ae}$ is isomorphic to $\apom'$, and define
\[
  \rseq[\apom][\apom'] = 
  [\esetof{\apom} \uplus \bigcup_{\ae \in \max \apom}\esetof{\apom'_{\ae}},
  \leq,
  \alfof{\apom} \uplus \bigcup_{\ae \in \max \apom}\alfof{\apom'_{\ae}}]
\]
where $\leq$ is the reflexo-transitive closure of
$\leqof{\apom} \cup \bigcup_{\ae \in \max \apom}\leqof{\apom'_{\ae}}
\cup \leqof{\apom'} \cup \{(\ae,(\ae,\ae')) \sst \ae \in
\esetof{\apom} \land (\ae,\ae') \in \esetof{\apom'_{\ae}} \land
\roles{\alfof{\apom}(\ae)} = \roles{\alfof{\apom'}(\ae')}\}$ (recall
that the labels of events are autonomous prefixes for which
$\roles{}$ is a singleton).
%
\eMnote{quando $\leq = \leqof{\apom} \uplus \leqof{\apom'}$ abbiamo il parallelo}
%
Finally, for $h \geq 1$ and a pomset $\apom$ we define
\[
  \apom^h =
  \begin{cases}
    r & \text{if } h = 1
    \\
    r \pomsetcup r^{h-1} & \text{if } h > 1
  \end{cases}
\]
The operation $\_^h$ extends element-wise to sets of pomsets.

The labels of the events are (decorations of) autonomous prefixes
$\apref$: labels are either just autonomous prefixes $\apref$
or of the form $\alabel$ with $\apref$ an autonomous prefix.
%
Intuitively, a label $\alabel[@][][\arole][@][@][.]$
(resp. $\alabel[@][\arole][][@][@][.]$) represents the fact that the
$i^\mathit{th}$ instance of $\arole$ consumed (resp. produced) a tuple
of type $\atuple$.
%
Labels $\apref$ not prefixed with $[\_]$ simply specify that the event
can be performed by any instance of the role in $\apref$.

The semantics of a global type builds upon \emph{basic pomsets} $\bp$
of prefixes $\apref$; in fact, the semantics of a global type is build
by taking sets of disjoint unions of basic pomsets of prefixes
sequentially composed together.
% 
Let $h \geq 1$ and define
%
\begin{align*}
  \bp =
  &
    \left\{ \pomsetrep{\node {$\alabel$}}[] \right\}
  \\
  \bp[@][{\apref[\arole][\arole'][@][@][.]}] =
  &
    \begin{cases}
      \left\{
        \pomsetrep{
        \node (out) {$\alabel[@][\arole][][@][@][.]$};
        \node[below = of out] (in) {$\alabel[@][][\arole'][@][@][.]$};
        \draw[->] (out) -- (in);
      }[]\right\}
      &
      \text{if } \arole' \in \participants \cup \multiroles^\unknownop \text{ or $\atuple$ generates} 
      \\
      \bigcup_{h \geq 1}
      \left\{
        \pomsetrep{
          \node (out) {$\alabel[@][\arole][][@][@][.]$};
          \node[below left = of out] (rd1) {$\ae_1$};
          \node[below = of out] (dots) {};
          \node[below right = of out] (rd2) {$\ae_h$};
          \draw[->] (out) -- (rd1);
          \draw[->] (out) -- (rd2);
          \draw[dotted] (rd1) -- (rd2);
        }[(\ae_j \mapsto {\apref[][\arole'][@][@][.]})_{1 \leq j \leq h}][][node distance = 1cm and -.25cm]\right\}
      \cup
      \left\{
        \pomsetrep{\node {$\alabel[@][\arole][][@][@][.]$}}[]
      \right\}
    &
    \text{otherwise}
    \end{cases}
\end{align*}
%
Let $\arole,\arole' \in \multiroles$
%
\begin{align*}
  \bp[@][{\apref[\arole][\arole']}] =
  &
    \left\{
    \pomsetrep{
    \node (out) {$\alabel[@][\arole][]$};
    \node[below left = of out] (rd1) {$\ae_1$};
    \node[below = of out] (dots) {};
    \node[below right = of out] (rd2) {$\ae_h$};
    \node[below = of dots] (in) {$\alabel[@][][\arole']$};
    \draw[->] (out) -- (rd1);
    \draw[->] (out) -- (rd2);
    \draw[->] (rd1) -- (in);
    \draw[->] (rd2) -- (in);
    \draw[dotted] (rd1) -- (rd2);
    }[(\ae_j \mapsto {\apref[][\arole'][@][@][.]})_{1 \leq j \leq h}][][node distance = 1cm and -.25cm]\right\}
    \cup
    \left\{
    \pomsetrep{
    \node (out) {$\alabel[@][\arole][]$};
    \node[below = of out] (in) {$\alabel[@][][\arole']$};
    \draw[->] (out) -- (in);
    }[]
    \right\}
\end{align*}

\begin{align*}
  \ksem{\apref} =
  &
    \begin{cases}
      \bp[1][\apref]
      & \text{if $\apref$ autonomous } \land \roles{\apref} \subseteq \participants \cup \multiroles^\unknownop
      \\
      \bigcup_{i \geq 1}\bp[@][\apref]
      % \bigcup_{h \geq 1}\big\{\pomsetrep{
      % \node {$\alabel[1]\cdots\alabel[h]$};
      % }[]\big\},
      & \text{if $\apref$ autonomous } \land \roles{\apref} \not\subseteq \participants \cup \multiroles^\unknownop
    \end{cases}
%  \qquad \text{if $\apref$ autonomous}
  \\
  \ksem{\apref[\arole][\arole'][@][@][.]} =
  &
    \begin{cases}
      \bp[1][{\apref[\arole][\arole'][@][@][.]}]
      & \text{if } \arole \in \participants \cup \multiroles^\unknownop
      \\
      \bigcup_{i \geq 1}\bp[@][{\apref[\arole][\arole'][@][@][.]}]
      & \text{otherwise}
    \end{cases}
  \\
  \ksem{\apref[\arole][\arole']} =
  &
    \begin{cases}
      \bp[1][{\apref[\arole][\arole']}]
      & \text{if } \arole \in \participants \cup \multiroles^\unknownop
      \\
      \bigcup_{i \geq 1}\big(\bp[@][{\apref[\arole][\arole']}]\big)
      & \text{otherwise}
    \end{cases}
  \\
  \ksem \asum =
  &
    \begin{cases}
      \{ \emptypom \} & \text{if } I = \emptyset
      \\
      \bigcup_{\apom \in \ksem{\apref_i},\apom' \in \ksem{\aK_i}} \rseq[\apom][\apom']
      & \text{otherwise}
    \end{cases}
\end{align*}
\eMnote{solo unfolding finiti?}
The semantics of $\arec$ is the union of the semantics of all
unfoldings of $\arec$.

\hsl


The \emph{well-formedness} of our global views presents some
peculiarities respect to standard notions.
%
In particular, \emph{well-sequencedness} and \emph{well-branchedness}
of our global types need some care.
%
We consider well-sequencedness first.

Consider the following choreography
\begin{align}\label{eq:seq}
  \apref[\ptp a][\ptp b][{\asort[str] \cdot \wildcard}][\aloc] \seqop \apref[\ptp b][\ptp c][{\asort[str] \cdot \asort[int]}][\aloc]
\end{align}
%
where intuitively requires an instance of $\ptp b$ to transform a pair
generated by $\ptp a$ into a pair for $\ptp c$.
%
The choreography specified in \eqref{eq:seq} may be violated when
$\ptp a$ generates a tuple of type $\asort[str] \cdot \asort[int]$.
%
In fact, such a tuple could match the type consumed by $\ptp c$ and
therefore $\ptp c$ could \quo{steal} the tuple from $\ptp b$.
%
The problem is due to the fact that ($i$) the input of $\ptp c$
causally depends on the output of $\ptp a$, that ($ii$) the input
could match the tuple sent by $\ptp a$, and that ($iii$) $\ptp c$
can consume the tuple sent by $\ptp a$ because it is on the same
locality $\aloc$.
%
More generally, write $(\atuple, \aloc) \in \aK$ when there is a
prefix in $\aK$ whose tuple is $\atuple$ and whose location is
$\aloc$; we say that $(\atuple, \aloc)$ is \emph{local} to $\aK$ if
either of the following holds:
\begin{itemize}
\item $\aK = \asum[@][@][][]$ there is $i \in I$ such that either
  $(\atuple, \aloc)$ is local to $\aK_i$ or $\apref_i$ outputs
  $\atuple$ at $\aloc$ and there is $\atuple'$ in an input from
  $\aloc$ in $\aK$ and $\atuple \matches \atuple'$
\item $\aK = \aK_1 \seqop \aK_2$ either $(\atuple, \aloc)$ is local to
  $\aK_1$ or   $(\atuple, \aloc)$ is local to $\aK_2$
\item $\aK = \arec[@][\aK']$ $(\atuple, \aloc)$ is local to $\aK'$
\end{itemize}
%
A choreography $\aK_1 \seqop \aK_2$ is \emph{well-sequenced} if any
participant $\ptp a$ performing actions in $\aK_2$ $\ptp a$ acts in
$\aK_1$ as well and all the first actions of $\ptp a$ in $\aK_2$
causally depend on all last actions of $\ptp a$ in $\aK_1$; moreover,
for $i \neq j \in \{1,2\}$
%
\begin{itemize}
\eMnote{is this clear or should be introduce the terminology more explicitely?}
\item for all $(\atuple,\aloc)$ local to $\aK_i$ and for all
  $(\atuple', \aloc) \in \aK_j$, $\atuple \matches \atuple'$ implies
  $(\atuple', \aloc)$ is in a read-only prefix in $\aK_j$
\item for all $(\atuple,\aloc)$ in a non-local consuming-input prefix
  of $\aK_i$ and for all $(\atuple', \aloc)$ in an output prefix of
  $\aK_j$, $\atuple \matches \atuple'$ implies $(\atuple',\aloc)$ is
  in a consuming output prefix in $\aK_j$
  
\end{itemize}
such that $\atuple_i$ occurs in a prefix of
$\aK_i$ both at a locality $\aloc$,
\eMnote{Problema: $\aloc$ vs $\alocvar$}

\hsl

To avoid this problem we introduce \emph{run-time} tuples

Well-branchedness requires two conditions: single selector and knowledge of 
choices.
%
This can be formalised by requiring that one process in the choice is
\emph{active}, namely it selects the branch to take, while the others
are \emph{passive}, namely they are informed of the chosed branch by
inputting some information that unambiguously identifies each branch
of the choice.
%
As anticipated in \cref{sec:klaimographies}, we syntactically enforce
the first condition; in choice
\begin{align}
  \asum\label{eq:ch}
\end{align}
an instance of $\arole$ is the active process selecting the branch to take.


The notion of well-branchedness is slightly complicated by the
presence of multiroles.
%
Intuitively, a passive instance (for example one enacting role
$\arole_i$) in \eqref{eq:ch} has to be able to ascertain which branch
the selector decided when the choice was taken.
%
For instance, even assuming unique selectors, many instances of a
selector role could exercise choices concurrently.
%
This may create confusion if different branches generate matching
tuples on the a locality.
%
Therefore we need a mechanisms so that different \quo{groups} of
instances involved in concurrent resolutions of a choice do not
\quo{interfere} with each other.

\eMnote{add here dummy fields}


A simple way to ensure this is to require that the first input actions
of passive roles in the branches are \quo{disjoint} (\ie\ non matching
tuples or different locations).
%
This is just for simplicity as we could adopt more general definitions
similar to the one based on divergence points in \cite{gt16,gt17}.

\hsl
  %
  % The notion of well formedness seems to guarantee a much weaker
  % notion of correctness than the usual ones.
  % %
  % Firstly, note that well-formedness here does not imply deadlock
  % freedom (but this is fine since we are not interested in properties
  % of the control of processes).
  % %
  %
  % A example could be the following:
  \[
    K_\mathrm{bad} = \apref[A][B][int].K_1 \chop \apref[A][B][str].K_2
  \]
  \[
    K_1 = \apref[B][C][str].\apref[C][B][bool]
  \]
  \[
    K_2 = \apref[B][C][bool]
  \]
  This type of confusion does not seem to introduce deadlocks, but may
  alter the intended data flow (in the example above the instance of
  $C$ executing $K_2$ branch may receive the boolean that the instance
  of $C$ in $K_1$ generates for $B$).
  %
  We can tackle this issue in two different way (at least): one way is
  to statically ensure that tuples generated on one branch do not
  match any other on another branch; another way is to modify the
  semantics of the choice by implicitly inserting an extra field in
  each tuple with a unique identifier of each branch.
  %
  \newline
  %
  Under the current interpretation of our semantics, probably the
  notion of correctness we can guarantee is that any set of instances
  taking a choice will fully execute a branch.



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
