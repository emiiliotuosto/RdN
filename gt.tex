
We fix two disjoint sets $\participants = \{\ptp p, \ptp q, \ldots\}$
and $\multiroles = \{\amulti P, \amulti Q, \ldots \}$, respectively of
\emph{participants} and \emph{multiple} roles, and define the set of
\emph{roles} $\roleset = \participants \cup \multiroles$.
% \cup \multiroles^\unknownstarop \cup
% \multiroles^\unknownop$ (ranged over by $\arole, \arole_1,
% \ldots$) where $\multiroles^{\unknownstarop} = \{\unknownstar \sst
% \amulti P \in\multiroles\}$ and $\multiroles^{\unknownop} = \{
% \unknown \sst \amulti p \in \multiroles
% \}$ account for some flexibility when implementing multiroles: an
% action involving a
% $\unknownstar$ role can be optionally executed by an implementation
% of role $\amulti P$, while
% $\unknown$ establishes that exactly one implementer must execute
% that action.
%
We conventionally write multiroles with initial uppercase letter and
unique roles with initial lowercase letter.
%
%We write $\eqR$ for the least equivalence relation on $\roleset$
%satisfying
%\[\amulti P \eqR \unknownstar \hspace{2cm} \amulti P \eqR \unknown\]

Roles are to be thought of as types inhabited by instances of
processes enacting the behaviour specified in a choreography.
%
Participants are unit types while multiroles account for multiple
instances of processes all performing actions according to their role.

We consider a set of localities $\locset$ ranged over by $\aloc$. We use 
$\alocvar$ to range over $\locset\cup\varset$.

Global types $\aK$ have the following syntax
%\eMnote{non e' chiaro se vogliamo $\aK \parop \aK $}
\begin{eqnarray*}
  \aK & \bnfdef & \asum
                  \bnfmid
                  % \aK \parop \aK \bnfmid
                  \aK; \aK \bnfmid
                  X \bnfmid
                  \arec
  \\[1.5em]
  \apref & \bnfdef & \apref[\arole][@][@][\alocvar] \bnfmid
                     \apref[\arole][{}][@][\alocvar][.] \bnfmid
                     \apref[{}][\arole][@][\alocvar] \bnfmid
                     \apref[{}][\arole][@][\alocvar][.]
  \\[1em]
        & \bnfmid & \apref[\arole][\arole'][@][\alocvar] \bnfmid
                    \apref[\arole][\arole'][@][\alocvar][.]
\end{eqnarray*}
where $I$ is a finite set of indexes.
% and $\aloc \in \locset$ is a locality.
%
We write $\nil$ for $\asum$ when $I = \emptyset$ and
$\apref_j.\aK_j$ instead of $\asum$ when $I = \{j\}$.
%
We omit trailing occurrences of $\nil$.
%
Note that we syntactically restrict choices to have a \emph{unique}
selector.
%
This is just for simplicity as we could adopt definitions similar to
the ones in \cite{gt16,gt17} at the cost of higher technical
complexity.

Tuple types are generated and accessed according to two modalities
syntactically distinguished by the round brackets around the tupe
in prefixes.
%
When a prefix surrounds a tuple $\atuple$ with round brackets then
$\atuple$ is meant to be consumed otherwise it is meant to be read
only.
%
Also, we syntactically distinguish two kinds of prefixes $\apref$.
%
The prefixes generated by the first four productions in the grammar of
$\apref$ above are the \emph{autonomous} prefixes, that is those
prefixes that processes can execute directly on a tuple space without
coordinating with other processes; the prefixes generated by the
remaining two productions of the grammar are the \emph{interaction}
prefixes, namely those involving a role generating tuples and a role
consuming/reading them.
%
The set $\roles \apref \subseteq \roleset$ of roles in $\apref$ is
defined in the obvious way; note that $\roles \apref$ is a singleton
if, and only if, $\apref$ is an autonomous prefix.
%
Likewise, $\roles \aK$ is the set of roles in
$\aK$.

We extend the notions of defined and free names to global types as
follows:
\[
 \fn{\apref[\arole][@][@][\alocvar]}
 = \fn \atuple \cup \{\alocvar \mapsto \asort[loc]\} 
\qquad
 \dn{\apref[\arole][@][@][\alocvar]} 
 = \dn \atuple 
\]
omitted prefixes are defined analogously.
\[
  \begin{array}{ll}
    \begin{array}{l@{\ =\ } ll}
      \fn{\asum[@][@][][]} & \displaystyle{\bigcup_{i\in I}} \fn{\apref_i} \cup (\fn{\aK_i}\setminus\dn{\apref_i})
      \\
      \fn{\aK_1; \aK_2} 
                &
                  \fn{\aK_1}\cup\fn{\aK_2}
      \\
      \fn X & \emptyset
      \\
      \fn \arec & \fn {\aK}
    \end{array}
    \begin{array}{l@{\ =\ } ll}
      \dn{\asum[@][@][][]} & \displaystyle{\bigcup_{i\in I}} \dn{\apref_i} \cup \dn{\aK_i}
      \\
      \dn{\aK_1; \aK_2} 
                           &
                             \dn{\aK_1}\cup\dn{\aK_2}
      \\
      \dn X & \emptyset
      \\
      \dn \arec & \dn {\aK}
    \end{array}
  \end{array}
\]
%
We write  $\names \_$ for the set of sorted names of a term, i.e., 
 $\names \apref = \fn\apref \cup \dn\apref$ and similarly
  $\names \aK = \fn\aK \cup \dn\aK$. A set $S$ of sorted names 
  is consistent, written $\consistent S$, if 
  $x\mapsto \asort \in S$ and $x\mapsto \asort' \in S$ 
  implies  $\asort = \asort'$.
 
The set of well-sorted terms 
are defined inductively as follows:

\begin{itemize}
\item $\apref$ is well-sorted if $\fn\apref\cap\dn\apref = \emptyset$ and  
$\consistent{\names\apref}$, i.e., there are no clashes/inconsistencies in the sorts of 
the names in $\atuple$ and the locality $\alocvar$.
\item $\asum$ is well-sorted if for all ${i\in I}$ both
  $\apref[\arole][{\arole_i}][\atuple_i][\alocvar_i]$ and ${\aK_i}$
  are well-sorted and $\consistent{\names {\apref_i.\aK_i}}$.
\item $\aK_1;\aK_2$ is well-sorted if $\aK_1$ and $\aK_2$ are
  well-sorted and $\consistent{\names{\aK_1;\aK_2}}$.
\item $X$ is well-sorted.
\item $\arec$ is well-sorted if $\aK$ is well-sorted.
\end{itemize}


We consider terms up-to $\alpha$-renaming of defined names. As usual
we say that a global type $\aK$ is {\em closed} when it does not
contain free occurrences of names, i.e.,
$\supp{\fn\aK} \cap \varset = \emptyset$.


\begin{example}\label{ex:cs}
  Consider the following global type that describes the interaction of
  a client $\ptp c$ with a simple service $\ptp s$ that converts
  integers into strings.
  \[
    \aK_\eqref{ex:cs} =
    \apref[\ptp c][\ptp s][{\asort[int]}][{\aloc[l]}].    
    \apref[\ptp s][\ptp c][{\asort[str]}][{\aloc[l]}].\nil
  \]
  The client $\ptp c$ produces an integer value on the locality
  $\aloc$.
  %
  This tuple must be consumed by the server $\ptp s$, which produces
  back the converted string for the client.
\end{example}

Elaborating on the previous examples we now discuss a few features
of our setting.

\begin{example}\label{ex:CS}
  Assume that we consider client and server in \cref{ex:cs} as
  multiroles instead of single participants, and write
  \[
    \aK_\eqref{ex:CS} =
    \apref[\amulti {C}][\amulti {S}][{\asort[int]}][{\aloc[l]}].
    \apref[\amulti {S}][\amulti {C}][{\asort[str]}][{\aloc[l]}].\nil
  \]
  In this case, $\aK_\eqref{ex:CS}$ states that each integer produced by a client
  will be consumed by a server, which will in turn produce a string
  for one of the clients.
\end{example}
The type in \cref{ex:CS} does not ensure that clients consume the
string conversion of the integer they produced.
%
Name binders can be used to correlate tuples.
%
\begin{example}\label{ex:CSx}
  Consider
  \[
    \aK_\eqref{ex:CSx} =
    \apref[\amulti {C}][\amulti {S}][{\nu x:\asort[int]}][{\aloc[l]}].
    \apref[\amulti {S}][\amulti {C}][{x : {\asort[int]}Â \cdot {\asort[str]} }][{\aloc[l]}].\nil
  \]
  $\aK_\eqref{ex:CSx}$ associates a fresh identifier $x$ to each value produced by
  a client and consumed by a server.
  %
  Despite the identifier is known only to the communicating instances,
  this does not forbid two clients to generate the same integer value.
  %
  Basically, the name $x$ allows to express constraints about the flow
  of values.
  %
  In particular, $x : \asort[int]$ in the second interaction states
  that a server must generate a tuple that contains the consumed
  integer.
  %
  Analogously, each client must consume a tuple matching the produced
  integer.
  %
  \finex
\end{example}
The choreography in \cref{ex:CSx} does not establishes a one-to-one
association between instances of $\amulti C$ and $\amulti S$.
%
In fact, an instance of $\amulti C$ not necessarily interacts with the
same instance of $\amulti S$ in the two communications when two
instances of $\amulti C$ generate the same integer in the first
interaction.
%
A one-to-one correspondence can be achieved by using fresh localities.
\begin{example}\label{ex:CSl}
  Consider
  \[
    \aK_\eqref{ex:CSl} = 
    \apref[\amulti {C}][\amulti {S}][{{\asort[int]} \cdot \nu x: {\asort[loc]}}][{\aloc[l]}].
    \apref[\amulti {S}][\amulti {C}][{{\asort[str]}}][{x}].\nil
  \]
  %
  A client generates a fresh locality identified by $x$, which is then
  used as the locality for the subsequent communication.
  %
  Since the name $x$ is known only to the two communicating instances,
  the second interaction can only take place between the two instances
  that know the locality $x$.
  %
  \finex
\end{example}

\todo[inline]{We think we can also deal with situations like the following, in which 
A creates a private session for B and C. 
%
\[
  \apref[\amulti {A}][\amulti {B}][{\nu y: {\asort[loc]}}][{\aloc[l]}]
\]
\[
  \apref[\amulti {A}][\amulti {C}][{y : {\asort[loc]}}][{\aloc[l]}].
\]
\[
  \apref[\amulti {B}][\amulti {C}][\asort][{y}]. \nil
\]
}


\begin{example}[Auction]

\[
  \begin{array}{l}
  \apref[\ptp {broker}][\amulti {Seller}][{\atuple[makeOffer]}][{\aloc[s]}][.].
  \\  	
  \apref[\amulti {Seller}][\amulti {Buyer}][{{\asort[str]} \cdot {\asort[int]} \cdot {\nu \aloc}}][{\aloc[c]}][.].
  \\
  \arec[@][\left({
    	\begin{array}{l}
	\apref[][\amulti {Buyer}][{i:{\asort[str]} \cdot p:{\asort[int]} \cdot \aloc[o]}][{\aloc[c]}][].
	\\
	\apref[\amulti {Buyer}][\amulti {Buyer}][{i \cdot {\asort[booked]}}][{\aloc[c]}][.].
	\\
	\arec[Y][\left({
    	\begin{array}{l}
	\apref[\amulti {Buyer}][\amulti {Seller}][{i \cdot {\asort[offer]} \cdot {\asort[int]}}][{\aloc[o]}][.].
	\\
	\apref[][\amulti {Seller}][{i \cdot \asort[offer]} \cdot  {\asort[int]}][{\aloc[o]}][].
	\\
	\qquad 
	\apref[\amulti {Seller}][\amulti {Buyer}][{i \cdot \asort[sold]}][{\aloc[c]}][.].
	\\
	\qquad\apref[][\amulti {Buyer}][i \cdot {\asort[booked]}][{\aloc[c]}][].
	X
	\\
	\qquad
	+
	\\
	\qquad
	\apref[\amulti {Seller}][\amulti {Buyer}][{i \cdot {\asort[request]}  \cdot \asort[int]}][{\aloc[o]}][.]. 
	\\
	\qquad
	\apref[][\amulti {Buyer}][i \cdot {\asort[request]} \cdot {\asort[int]}][{\aloc[o]}][].
	\\
	\qquad\qquad	
	Y
	\\
	\qquad\qquad	
	+
	\\ 
	\qquad\qquad\apref[][\amulti {Buyer}][i \cdot {\asort[booked]}][{\aloc[c]}][].
	\\
	\qquad\qquad
	\apref[\amulti {Buyer}][\amulti {Seller}][{i\cdot {\asort[quit]}}][{\aloc[o]}][.]. 
	\\
	\qquad\qquad
	\apref[\amulti {Seller}][\amulti {Buyer}][{i \cdot p \cdot {\nu \aloc}}][{\aloc[c]}][.].X
	\\
	\qquad
	+
	\\
	\qquad
	\apref[\amulti {Seller}][\amulti {Buyer}][{i\cdot {\asort[refused]}}][{\aloc[o]}][.]. 
	\\
	\qquad
	\apref[\amulti {Seller}][\amulti {Buyer}][{i \cdot p \cdot {\nu \aloc}}][{\aloc[c]}][.].
	\\
	\qquad
	\apref[][\amulti {Buyer}][{i \cdot \asort[refused]}][{\aloc[o]}][].
	\\
	\qquad\apref[][\amulti {Buyer}][i \cdot {\asort[booked]}][{\aloc[c]}][].
	X
	\end{array}
	}\right)]
	\\
	+
	\\
	\apref[][\amulti {Buyer}][{{\asort[str]} \cdot {\asort[booked]}}][{\aloc[c]}][.]. 
	X
	\\
	+
	\\
	\apref[][\amulti {Buyer}][{{\asort[str]} \cdot {\asort[sold]}}][{\aloc[c]}][.]. 
	X
	\\
	+
	\\
	\nil
  	\end{array}
  }\right)]
  \\
  \end{array}
\]
\finex
\end{example}

\eMnote{un'alternativa}
\begin{example}[Auction]
\[
  \begin{array}{l}
    \apref[\ptp {broker}][\amulti {Seller}][{\atuple[makeOffer]}][{\aloc[s]}][.].
    \\  	
    \arec[X][\left({
    \begin{array}{l}
      \apref[\amulti{Seller}][\amulti {Buyer}][s:{\asort[seller]} \cdot {i:{\asort[str]} \cdot p:{\asort[int]}}][{\aloc[m]}].
      \\\qquad
      X
      \\
      \chop
      \\
      \apref[\amulti {Buyer}][\amulti {Seller}][s \cdot i \cdot {\asort[offer]} \cdot \nu \aloc][{\aloc[m]}][.].
      \\\qquad
      \arec[Y][\left({
      \begin{array}{l}
	\apref[\amulti {Seller}][\amulti {Buyer}][{\asort[quit]}][\aloc].
	\\\qquad
	\apref[\amulti {Seller}][][s \cdot i \cdot p][{\aloc[m]}].
        \\
        \qquad
        X
        \\
        \chop
	\\
        \apref[\amulti{Seller}][\amulti {Buyer}][{\asort[sold]}][\aloc].
        \\\qquad
        \apref[\amulti{Seller}][\ptp{broker}][s \cdot i \cdot \aloc \cdot {\asort[fee]}][{\aloc[s]}].        
        \\
        \qquad
        X
	\\
        \chop
	\\
        \apref[\amulti {Seller}][\amulti {Buyer}][{\asort[more]}][\aloc].
        \\
        \qquad\apref[\amulti {Buyer}][\amulti {Seller}][{\asort[offer]}][{\aloc}][].
	\\
        \qquad	
	Y
      \end{array}
      } \right)]
    \end{array}
    }\right)]
    \\
  \end{array}
\]
\finex
\end{example}

% TBC: 

% Well-formedness (TBC): Besides the usual conditions about single selector and knowledge of 
% choices,  we assume the following conditions hold in any $\aK$.

% \begin{itemize}
% % \item $\roles {\aK_1}Â \cap \roles {\aK_2} = \emptyset$ if $\aK = \aK_1 \parop \aK_2$
% \item $\neg (\arole \eqR \arole')$ in $\apref[\arole][\arole']$ and
%   $\apref[\arole][\arole'][@][\aloc][.]$.
%   %
%   \todo[inline]{eM: does the restriction above apply only to branches? May be it can be relaxed under the new semantic interpretation...}
% \item the prefixes of each branch must generate
%   \todo[inline]{eM: may be not}
% \end{itemize}
%

The \emph{well-formedness} of our global views presents some
peculiarities respect to standard notions.
%
In particular, \emph{well-sequencedness} and \emph{well-branchedness}
of our global types need some care.
%
We consider well-sequencedness first.

Consider the following choreography
\begin{align}\label{eq:seq}
  \apref[\ptp a][\ptp b][{\asort[str] \cdot \wildcard}][\aloc] \seqop \apref[\ptp b][\ptp c][{\asort[str] \cdot \asort[int]}][\aloc]
\end{align}
%
where intuitively requires an instance of $\ptp b$ to transform a pair
generated by $\ptp a$ into a pair for $\ptp c$.
%
The choreography specified in \eqref{eq:seq} may be violated when
$\ptp a$ generates a tuple of type $\asort[str] \cdot \asort[int]$.
%
In fact, such a tuple could match the type consumed by $\ptp c$ and
therefore $\ptp c$ could \quo{steal} the tuple from $\ptp b$.
%
The problem is due to the fact that ($i$) the input of $\ptp c$
causally depends on the output of $\ptp a$, that ($ii$) the input
could match the tuple sent by $\ptp a$, and that ($iii$) $\ptp c$
can consume the tuple sent by $\ptp a$ because it is on the same
locality $\aloc$.
%
More generally, we say that $(\atuple, \aloc)$ is \emph{local} to
$\aK$ if $\atuple$ is in an output at $\aloc$ in $\aK$ and there is a
tuple $\atuple'$ in an input from $\aloc$ in $\aK$ and
$\atuple \matches \atuple'$.
%
The choreography $\aK_1 \seqop \aK_2$ is well-sequenced if 

given $\aK_1 \seqop \aK_2$ and, for $i \in \{1,2\}$,
tuple types $\atuple_i$ such that $\atuple_i$ occurs in a prefix of
$\aK_i$ both at a locality $\aloc$,
\eMnote{Problema: $\aloc$ vs $\alocvar$}

\hsl

To avoid this problem we introduce \emph{run-time} tuples

Well-branchedness requires two conditions: single selector and knowledge of 
choices.
%
This can be formalised by requiring that one process in the choice is
\emph{active}, namely it selects the branch to take, while the others
are \emph{passive}, namely they are informed of the chosed branch by
inputting some information that unambiguously identifies each branch
of the choice.
%
As anticipated in \cref{sec:klaimographies}, we syntactically enforce
the first condition; in choice
\begin{align}
  \asum\label{eq:ch}
\end{align}
an instance of $\arole$ is the active process selecting the branch to take.


The notion of well-branchedness is slightly complicated by the
presence of multiroles.
%
Intuitively, a passive instance (for example one enacting role
$\arole_i$) in \eqref{eq:ch} has to be able to ascertain which branch
the selector decided when the choice was taken.
%
For instance, even assuming unique selectors, many instances of a
selector role could exercise choices concurrently.
%
This may create confusion if different branches generate matching
tuples on the a locality.
%
Therefore we need a mechanisms so that different \quo{groups} of
instances involved in concurrent resolutions of a choice do not
\quo{interfere} with each other.

\eMnote{add here dummy fields}


A simple way to ensure this is to require that the first input actions
of passive roles in the branches are \quo{disjoint} (\ie\ non matching
tuples or different locations).
%
This is just for simplicity as we could adopt more general definitions
similar to the one based on divergence points in \cite{gt16,gt17}.

\hsl
  %
  % The notion of well formedness seems to guarantee a much weaker
  % notion of correctness than the usual ones.
  % %
  % Firstly, note that well-formedness here does not imply deadlock
  % freedom (but this is fine since we are not interested in properties
  % of the control of processes).
  % %
  %
  % A example could be the following:
  \[
    K_\mathrm{bad} = \apref[A][B][int].K_1 \chop \apref[A][B][str].K_2
  \]
  \[
    K_1 = \apref[B][C][str].\apref[C][B][bool]
  \]
  \[
    K_2 = \apref[B][C][bool]
  \]
  This type of confusion does not seem to introduce deadlocks, but may
  alter the intended data flow (in the example above the instance of
  $C$ executing $K_2$ branch may receive the boolean that the instance
  of $C$ in $K_1$ generates for $B$).
  %
  We can tackle this issue in two different way (at least): one way is
  to statically ensure that tuples generated on one branch do not
  match any other on another branch; another way is to modify the
  semantics of the choice by implicitly inserting an extra field in
  each tuple with a unique identifier of each branch.
  %
  \newline
  %
  Under the current interpretation of our semantics, probably the
  notion of correctness we can guarantee is that any set of instances
  taking a choice will fully execute a branch.
  %
  
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
