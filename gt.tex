% !TEX root =  main.tex
%

We fix two disjoint sets $\participants = \{\ptp p, \ptp q, \ldots\}$
and $\multiroles = \{\amulti P, \amulti Q, \ldots \}$, respectively of
\emph{unit} roles and \emph{multiple} roles, and define the set of
\emph{roles} $\roleset = \participants\, \cup\, \multiroles$, ranged over by $\arole$.
% \todo{AC: aggiunto}
% \cup \multiroles^\unknownstarop \cup
% \multiroles^\unknownop$ (ranged over by $\arole, \arole_1,
% \ldots$) where $\multiroles^{\unknownstarop} = \{\unknownstar \sst
% \amulti P \in\multiroles\}$ and $\multiroles^{\unknownop} = \{
% \unknown \sst \amulti p \in \multiroles
% \}$ account for some flexibility when implementing multiroles: an
% action involving a
% $\unknownstar$ role can be optionally executed by an implementation
% of role $\amulti P$, while
% $\unknown$ establishes that exactly one implementer must execute
% that action.
%
We conventionally write multiple roles with initial uppercase letter and
unit roles with initial lowercase letter.
%
%We write $\eqR$ for the least equivalence relation on $\roleset$
%satisfying
%\[\amulti P \eqR \unknownstar \hspace{2cm} \amulti P \eqR \unknown\]

Roles have to be thought of as types inhabited by instances of
processes enacting the behaviour specified in a choreography.
%
Unit roles are unit types while multiple roles account for multiple
instances of processes all performing actions according to their role.
%
%\todo{RB: forse \`e importante dire che tutti i multiruoli sono disgiunti, giusto?}
%\todo{eM: direi di no; in the long run vorremmo che un processo possa coprire piu' ruoli}

%
Let us first define the grammar for \emph{prefixes} used in global types:
%
% \todo{AC: localities are said to be ranged over by $\aloc$, but we use $\alocvar$ in the prefixes...}
% \todo{RB: ``consuming output'' mi sembra fuorviante... ma non ho proposte migliori}
%
\[\begin{array}{lcl@{\qquad\qquad}l}
  \apref & \bnfdef
  & \apref[\arole][@][@][\alocvar] & \text{(autonomous) output}
  \\ & \bnfmid
  & \apref[\arole][{}][@][\alocvar][.] & \text{(autonomous) read-only output}
  \\ & \bnfmid
  & \apref[{}][\arole][@][\alocvar] & \text{(autonomous) input}
  \\ & \bnfmid
  & \apref[{}][\arole][@][\alocvar][.] & \text{(autonomous) read}
  \\ & \bnfmid
  & \apref[\arole][\arole'][@][\alocvar] & \text{consuming interaction}
  \\ & \bnfmid
  & \apref[\arole][\arole'][@][\alocvar][.]  & \text{read-only interaction}
  \end{array}
\]
%
The set $\roles \apref \subseteq \roleset$ of roles in $\apref$ is
defined in the obvious way; note that $\roles \apref$ is a singleton
if, and only if, $\apref$ is an autonomous prefix.
%
We syntactically distinguish two kinds of prefixes.
%
The prefixes generated by the first four productions in the grammar of
$\apref$ above are the \emph{autonomous} prefixes, that is those
prefixes that processes can execute directly on a tuple space without
coordinating with other processes. 
They are analogous to Klaim primitives for Linda-like interactions.
%
The prefixes generated by the remaining two productions 
are the \emph{interaction} prefixes, namely those involving a role
generating a tuple and one accessing it.
They are analogous to the usual prefixes of global types.
%
Inspired by Klaim, processes can access tuple types according to two
modalities syntactically distinguished by the round brackets around
the tuple in prefixes.
%
More precisely, when a prefix surrounds a tuple $\atuple$ with round
brackets then $\atuple$ is meant to be consumed otherwise it is meant
to be read-only.
%
% We call \emph{read-only outputs} and \emph{reads} the autonomous
% read-only prefixes while those prescribing the consumption of tuples,
% and consuming (resp. read-only) interactions the interations
% prescribing inputs (resp. reads).
%

\eMnote{Una variante interessante e' quella dove questo vincolo e' rilassato.}
{
  We assume that tuple types used in read-only modalities do not
  generate.
}
%

Global types $\aK$ have the following syntax
% \eMnote{non e' chiaro se vogliamo $\aK \parop \aK $}
\begin{eqnarray*}
  \aK & \bnfdef & \asum[@][@][][]
                  \bnfmid
                  % \aK \parop \aK \bnfmid
                  \aK \seqop \aK \bnfmid
                  X \bnfmid
                  \grec
\end{eqnarray*}
% \todo{RB: avendo $\seqop$ direi che il parallelo non \`e necessario}
where $I$ is a finite set of indexes; we write $\nil$ for
$\asum[@][@][][]$ when $I = \emptyset$ (we omit trailing occurrences
of $\nil$) and $\apref_j.\aK_j$ instead of $\asum[@][@][][]$ when
$I = \{j\}$.
%
The set $\roles \aK \subseteq \roleset$ of roles of $\aK$ is the set of roles that are mentioned in $\aK$ and it is defined in the obvious way.

The syntax of global types features prefix guarded choices, sequential
composition, and recursion.
%
To handle recursive behaviour, 
%\todo{AC+RB: il comportamento della ricorsione si intuisce solo dopo aver visto la semantica. Forse bisognerebbe tentare di spiegarlo intuitivamente?}
%\todo{eM: ora?}
the construct $\grec$ singles out a role $\arole \in \roles \aK$
%
% and specifies an injective function
% $\aphi : \roles \aK \setminus \{\arole\} \to \locset$ such that the
% locations in $\cod(\aphi)$ do not occur in $\aK$; intuitively,
% $\arole$
deciding when the recursion ends.
%\todo{RB: pi\`u sotto viene usata la notazione $\alvar$ invece di $X$: bisogna cambiare la grammatica delle coreografie?}
% and, for all $\arole' \neq \arole$ in $\aK$, the location
% $\aphi(\arole')$ is used to communicate the decision of $\arole$ to
% $\arole'$.
%
Intuitively, in $\grec$ role  $\arole$ non-deterministically decides whether 
to repeat the execution of  the body $\aK$  or (if ever) to end it.
%
To achieve this,  $\arole$ notifies the decision to stop or to do a next iteration by generating tuple types for the
other roles (this is formally defined in \cref{sec:globsem}).
%
We omit the decoration $\arole$ when $\roles \aK = \{\arole\}$.

We extend the notions of defined and free names to global types as
follows:
%\todo{RB: ma la $\nu$ pu\`o essere usata anche in una tupla di input/read (senza output)?}
%\todo{eM: si, ma poi non sincronizza}
\[
 \fn{\apref[\arole][@][@][\alocvar]}
 = \fn \atuple \cup \{\alocvar \mapsto \asort[loc]\} 
\qquad
 \dn{\apref[\arole][@][@][\alocvar]} 
 = \dn \atuple 
\]
omitted prefixes are defined analogously.
\[
  \begin{array}{ll}
    \begin{array}{l@{\ =\ } ll}
      \fn{\asum[@][@][][]} & \displaystyle{\bigcup_{i\in I}} \fn{\apref_i} \cup (\fn{\aK_i}\setminus\dn{\apref_i})
      \\
      \fn{\aK_1 \seqop \aK_2} 
                &
                  \fn{\aK_1}\cup\fn{\aK_2}
      \\
      \fn X & \emptyset
      \\
      \fn \grec & \fn {\aK}
    \end{array}
    &
    \begin{array}{l@{\ =\ } ll}
      \dn{\asum[@][@][][]} & \displaystyle{\bigcup_{i\in I}} \dn{\apref_i} \cup \dn{\aK_i}
      \\
      \dn{\aK_1 \seqop \aK_2} 
                           &
                             \dn{\aK_1}\cup\dn{\aK_2}
      \\
      \dn X & \emptyset
      \\
      \dn \grec & \dn {\aK}
    \end{array}
  \end{array}
\]
%
We remark that in $\aK_1 \seqop \aK_2$ the scope of names defined in $\aK_1$ does not include $\aK_2$.
We write $\names \_$ for the set of sorted names of a term, i.e.,
$\names \apref = \fn\apref \cup \dn\apref$ and similarly
$\names \aK = \fn\aK \cup \dn\aK$.
%
A set $S$ of sorted names is \emph{consistent} if
$x\mapsto \asort \in S$ and $x\mapsto \asort' \in S$ implies
$\asort = \asort'$.
 
The sets of well-sorted prefixes and terms are defined inductively as
follows:
\begin{itemize}
\item $\apref$ is well-sorted if $\fn\apref\cap\dn\apref = \emptyset$
  and $\names\apref$ is consistent, i.e., there are no
  clashes/inconsistencies in the sorts of the names in the component
  $\atuple$ of $\pi$ and the locality $\alocvar$ mentioned in $\pi$;
\item $\asum[@][@][][]$ is well-sorted if for all ${i\in I}$ both
  $\apref_i$ and ${\aK_i}$ are well-sorted and
  $\names {\apref_i.\aK_i}$ is consistent;
  %
  \todo{AC: in the sum, consistency is required in each branch, but
    not globally: this looks reasonable. But with the present
    definition, I may have a $\aK_1$ well-sorted (a sum), $\aK_2$
    well-sorted, $\names{\aK_1} \cap \names{\aK_2} = \emptyset$ and
    $\aK_1 \seqop \aK_2$ not well-sorted (by the requirement
    $\names{\aK_1 \seqop \aK_2}$ is consistent).
    %
    This does not look reasonable.}
  \todo{eM \& HM: non capiamo il problema sollevato da Andrea}
  \item $\aK_1 \seqop \aK_2$ is well-sorted if $\aK_1$ and $\aK_2$ are
  well-sorted and $\names{\aK_1 \seqop \aK_2}$ is consistent;
\item $X$ is well-sorted and $\grec$ is well-sorted if $\aK$ is
  well-sorted.
\end{itemize}


We consider terms up-to $\alpha$-renaming of defined names and
recursion variables.
%
Correspondingly, substitutions are capture avoiding, in the sense that
defined names can be renamed to fresh names before any substitution is
applied to a term.
% \todo{RB: aggiunto}
%
As usual we say that a global type $\aK$ is \emph{closed} when it does
not contain free occurrences of recursion variables $X$ or free
occurrences of names.%, i.e., $\supp{\fn\aK} \cap \varset = \emptyset$.


  
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
