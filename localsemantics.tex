% !TEX root =  main.tex
%

A {\em local type} $\aL$, which describes the interaction from the
perspective of a single role, is a term generated by the following
grammar.
%
% \todo{RB: per i tipi locali $\seqop$ \`e davvero la composizione
%   sequenziale: meglio usare un simbolo diverso, ad esempio ;? Notare
%   che poi nella definizione di $\proj$ (caso 7) si usa ;
% }
% \todo{eM \& HM: ci avevamo pensato, ma poi abbiamo optato per consistenza; se volete cambiate pure.}
% \todo{RB: cambiato con macro}
\begin{eqnarray*}
  \aLpref & \bnfdef &
%                  \aout[] \bnfmid
                  \arout[]\bnfmid
                  \ain[] \bnfmid
                  \ard[] 
\\
  \aL & \bnfdef &
                  \aLsum \bnfmid
                  \aL \lseqop \aL \bnfmid
                   \alrec \bnfmid
  	        \alvar%[{\alvar[@][x_1,\ldots,x_n]}][\aL]
\end{eqnarray*}
%\todo{RB: nella formula sopra compare un carattere strano che mi causa errore di compilazione: l'ho messo tra parentesi, si pu\`o togliere?, HM: adesso?}

Prefixes $\arout[]$, $\ain[]$ and $\ard[]$ respectively stand for the
production, consumption and read of a tuple $\atuple$ at the locality
$\alocvar$. Differently from global types, local types do not
distinguish the generation of read-only tuples from the ones that can
be consumed.
%
Also, we use the symbol $\lseqop$ instead of $\seqop$ to remark the fact that,
on local types, the sequential operator $\lseqop$ serialises all activities.

Formation rules for branching and sequential local types $\aL$ are
exactly the same as for global types; analogously we write $\nil$ for
an empty sum.  The syntax of recursive local types deviates from
global types to make explicit the localities used for coordinating the
execution; consequently, process variables are parametric (the syntax
for recursive types is borrowed from~\cite{bhty10}).  The term $\alrec$
defines a process variable $X$ with parameters $\seq x$ to be used in
$\aL$; the initial values of $\seq x$ are given by
$\seq\alocvar$. Accordingly, the usage of a process variable is
parameterised, i.e., $\alvar$.  For any $\alrec$, we assume that
$|\seq x| = |\seq \alocvar|$ and $|\seq x| = |\seq {\alocvar'}|$ for
any bound occurrence of $\alvar[@][\alocvar']$ in $\aL$.


The notions of free and defined names, well-sorted and closed terms
are straightforwardly extended to local types; in $\alrec$, $X$ and
$\seq x$ act as binders for the occurrence in $\aL$.
%
%
%The definition of $\fn\_$ is extended to local types 
%\begin{eqnarray*}
%  \fn {\aout[]}  & = & \fn {\arout[]} = \fn {\ain[]} = \fn {\ard[]} = \fn {\atuple} \cup \{\aloc\}  
%  \\
%  \fn {\aLsum} & = & \bigcup_{i\in I} \fn{\aLpref_i}\cup (\fn {\aL_i}\setminus \dn{\aLpref_i}) 
%  \\
%  \fn {X} & = & \emptyset 
%  \\
%  \fn {\arec[@][\aL]} & = & \fn {\aL} 
%\end{eqnarray*}
%
Substitution on local types is defined as follows.
% 
% \todo{RB: ma nella somma la sostituzione non si applica al prefisso $\aLpref_{i}$? Oppure il termine nella sommatoria dovrebbe leggersi $({\aLpref_{i}.\aL_{i}})\sust x y$? (ma la sostituzione non \`e definita per il prefisso)}
% \todo{eM: check now; a me sembra che la sostituzione non \`e definita per il prefisso (prime 3 equaz.)}
% \todo{RB: cos\`\i\ ok per me}
 \[
\begin{array}{rl@{\hspace{.3cm}}l}
  (\arout[]) \sust x y  = &  \arout[][\atuple\sust x y][(\alocvar\sust x y)] &  {\it if}\  x\not\in\dn\atuple
  \\
  (\ain[]) \sust x y  = &  \ain[][\atuple\sust x y][(\alocvar\sust x y)] &  {\it if}\  x\not\in\dn\atuple
  \\
  (\ard[]) \sust x y  = &  \ard[][\atuple\sust x y][(\alocvar\sust x y)] &  {\it if}\  x\not\in\dn\atuple
%  \\ 
%  \fn {\arout[]} = & 
%  \\
%  \fn {\ain[]}  = &
%  \\
%  \fn {\ard[]}  = &
  \\
   (\aLsum)\sust x y  = & \displaystyle{\sum_{i\in I} {(\aLpref_{i}\sust x y).(\aL_{i}\sust x y)}}
   &  {\it if}\  \forall i. x\not\in\dn{\aLpref_i}
  \\
  (\aL_1\lseqop\aL_2)\sust x y  = &  \aL_1\sust x y\lseqop  \aL_2\sust x y 
  \\
  \alvar\sust x y  = & \alvar[@][\seq\alocvar\sust x y]  
  \\
  (\alrec[@][\seq z])\sust x y  = & \alrec[@][\seq z][\aL\sust x y][\seq\alocvar\sust x y] &  {\it if}\  \{x,y\}\cap\seq z = \emptyset
\end{array}
\]
%
%
%Let $s$ and $t$ in $\locset$  local types up-to $\alpha$-renaming of binders. 
%
%
%For a local type $\aL = \aLsum$, we write $\selectors \aL$ for the selecting roles the choice, i.e.,
%$\selectors \aL = \cup_{i\in I}{\{\arole_i\}}$.
%%
%Moreover, we assume
%\begin{itemize}
%\item $\aL_i \neq\aLsum[j][J]$, for all $i \in I$.
%\item $\arole_i \eqR \arole_j$ for all $i,j \in I$.
%\end{itemize}
%
As for global types, we consider terms up-to $\alpha$-renaming.
 
We consider the following syntax for the run-time semantics of a set
of local types running on a tuple space, dubbed \emph{specification}.
%
\begin{eqnarray*}
  \envmv & \bnfdef & \emptyset \bnfmid
                  \envmv, \arole :  \aL \bnfmid
%                  \envmv, \atupleat \bnfmid
                  \envmv, \artupleat[@][@][\aloc]                  
\end{eqnarray*}
%
% \todo{eM: $\alocvar$ non dovrebbe comparire nelle tuple locate delle specifiche}
% \todo{RB: credo che possa succedere: solo a livello delle etichette delle transizioni le variabili sono istanziate a locazioni}
%
A specification is a multiset containing two kind of pairs:
$\arole : \aL$ associates a role with a local type; while $\artupleat[@][@][\aloc]$
indicates that a tuple of type $\atuple$ is available at locality
$\aloc$.
%In $\arole :  \aL$  we assume
%$\arole \in \participants \cup \multiroles$  and $\arole \eqR \arole'$ for any $\arole'$
%occurring in $\aL$.
%
We sometimes write $\envtuple$ to denote a specification containing only
terms of the form $\artupleat[@][@][\aloc]$. 

The definition of $\fn{\_}$ is straightforwardly  extended to specifications. 

We give an operational semantics to local types defined inductively by 
the rules in \cref{fig:local-types-sem}, where labels $\alpha$ are of the form 
$\arole : \aLpref$. Rule $\rulename{LOut}$ 
accounts  for the behaviour of a role $\rho$ that  generates a tuple type $\atuple$ at the 
locality $\aloc$. The operational semantics for the generation of a tuple $\atuple$ that 
contains binders ensures that  each defined name  is substituted by a fresh free variable 
 (i.e., a variable that does not occur free in $\envmv, \arole : \arout[][@][\aloc].\aL$).
This is achieved by requiring  (i) all bound names in $\atuple$ to be fresh by $\alpha$-renaming them if necessary (i.e., $\dn\atuple$  fresh) and 
(ii)  the generated tuple $\eraseB\atuple$ is the binder-free version of $\atuple$. 
Rule $\rulename{LIn}$ handles the case in which a role $\arole$
consumes  a tuple specified as $\atuple$ from locality $\aloc$. In order for the consumption to
take place, the  requested tuple $\atuple$ should match  a tuple $\atuple'$ available 
at the locality $\aloc$. 
Note that the substitution $\sigma$ generated from the match is applied 
to the continuation $\aL$ associated with the role $\arole$; the
consumed tuple is eliminated from the locality $\aloc$. 
%
Rule $\rulename{LRd}$ is analogous to $\rulename{LIn}$, but the 
read tuple is not removed from the tuple space.
%
Rule $\rulename{LSum}$ accounts for a role that follows by choosing one of 
its enabled branches. 
%
The semantics of a recursive term $\alrec[@][@][@][\seq \aloc]$ is
given by the rule $\rulename{LRec}$, which unfolds the definition,
i.e., $\aL\sust X{\abasiclrec}$ and substitutes the formal parameters
$\seq x$ of the recursive definition by the actual parameters
$\seq\aloc$ via the substitution
$\sust {\seq x}{\seq \aloc}$.
 

%\eMnote{nelle etichette delle conclusioni di Lin e LRd non dovrebbe essere $\atuple$ invece di $\atuple'$?} 
\begin{figure}[t]
\[
\begin{array}{l@{\quad\quad}l}
%\mathrule{\dn\atuple\ {\it fresh}}
%	{\envmv, \arole : \aout[][@][\aloc].\aL 
%	 \red[\arole : {\aout[][\eraseB\atuple][\aloc]}]
%	 \envmv, \arole : \aL , \atupleat[@][\eraseB\atuple][\aloc]}
%	{LOut_1} 
%\\[25pt]
\mathrule{\dn\atuple\ {\it fresh}}
	{\envmv, \arole : \arout[][@][\aloc].\aL 
	 \red[\arole : {\arout[][\eraseB\atuple][\aloc]}]
	 \envmv, \arole : \aL , \artupleat[@][\eraseB\atuple][\aloc]}
	{LOut}
&
\mathrule
	{\atuple \matches \atuple' \generates \sigma}
	{\envmv, \arole : \ain[][@][\aloc].\aL, \artupleat[][\atuple'][\aloc]
	 \red[\arole : {\ain[][\atuple'][\aloc]}]
	 \envmv, \arole : \aL\sigma}
	{LIn}
\\[25pt]
%\mathrule
%	{\atuple \matches \atuple' \generates \sigma}
%	{\envmv, \arole : \ard[][@][\aloc].\aL, \atupleat[][\atuple'][\aloc] 
%	 \red[\arole : {\ard[][\atuple'\sigma][\aloc]}]
%	 \envmv, \arole : \aL\sigma,  \atupleat[][\atuple'][\aloc] }
%	{LRd_1}
%\\[25pt]
\mathrule
	{\atuple \matches \atuple'\generates \sigma}
	{\envmv, \arole : \ard[][@][\aloc].\aL, \artupleat[][\atuple'][\aloc] 
	 \red[\arole : {\ard[][\atuple'][\aloc]}]
	 \envmv, \arole : \aL\sigma,  \artupleat[][\atuple'][\aloc] }
	{LRd}
&
\mathrule
	{\envtuple, \arole : \aLpref_j.\aL_j \red[\alpha] \envmv'}
	{\envmv, \envtuple, \arole : \aLsum
	 \red[\alpha]
	 \envmv,\envmv'}
	{LSum} \qquad j\in I
\\[25pt]
\mathrule
	{\envmv, \arole : \aL_1  \red[\alpha] \envmv', \arole : \aL'_1 }
	{\envmv, \arole : \aL_1\lseqop\aL_2
	 \red[\alpha]
	 \envmv', \arole : \aL'_1\lseqop\aL_2}
	{LSeq_1} 
&
\mathrule
	{\envmv, \arole : \aL_1  \red[\alpha] \envmv', \arole : \nil }
	{\envmv, \arole : \aL_1\lseqop\aL_2
	 \red[\alpha]
	 \envmv', \arole : \aL_2}
	{LSeq_2} 
  \\[25pt]
  \multicolumn 2 c {
  \mathrule
  {\envmv, \arole : \aL\sust X{\abasiclrec}\sust {\seq x}{\seq \aloc} \red[\alpha] \envmv'}
  {\envmv, \arole : \alrec[@][@][@][\seq \aloc] \red[\alpha] \envmv'}
  {LRec}
  }
\end{array}
\]
\caption{Semantics of local types}
\label{fig:local-types-sem}
\end{figure}


\subsection{Obtaining local types out of global types}
\label{sec:proj}

The projection of a global type $\aK$ over a role $\arole$, 
written $\proj[@][@][\ ]$,  denotes the local type that specifies 
the behaviour of  $\arole$ in $\aK$. 
% 
Our projection operation is fairly standard but for the case of
recursive types, which coordinate their execution by communicating
over dedicated locations.
%
%
Note that the semantics of recursive global types $\grec$ introduces
auxiliary interactions to coordinate their execution (see
$\mathit{STOP}(\arole, \aK, \seq y)$ and
$\mathit{LOOP}(\arole, \aK, \seq y, \seq y')$ in \cref{sec:globsem}).
%
However, there is not such an implicit mechanism in the 
execution of local types, where recursion is standard. 
%
Consequently, those auxiliary interactions need to be defined
explicitly in local types; and consequently, they are introduced by
projection (similarly to the approach in~\cite{bmt14}).
%
Another subtle aspect of the semantics of a recursive global type is that 
each iteration  is parametric with respect to the set of localities used 
for coordination. In fact,  $\mathit{LOOP}(\arole, \aK, \seq y, \seq y')$
generates a set of fresh localities  that are 
used by the next iteration. Such behaviour is mimicked by local types by 
relying on parameterised process variables. As a consequence,
projection depends on the locations that are chosen as parameters  
of process variables. Hence, $\proj[@][@][\ ]$ is defined in terms 
of $\proj$, where $\eta$ is a partial function that maps 
process variables into sequences of locations, i.e., 
$\eta X = \seq\alocvar$; and $\proj[@][@][\ ] = \proj[@][@][\emptyset]$.
\begin{figure}[t]
 \[
  \proj =\left\{
  \begin{array}{l@{\quad}l@{\ \ }l}
    \nil & \text{if }\ \arole \not \in \roles \aK
    \\[10pt]
    \proj[\aK']
    &
    \multicolumn{2}{l}{
    \text{if }\ \aK = \apref.\aK' \text{ and } \rho\not\in\roles{\apref}}
%    \\
%    \aout[].(\proj[\aK'])
%    &
%    \text{if } \aK = \apref[\arole].\aK'
    \\[10pt]
    \arout[].(\proj[\aK'])
    &
    \text{if }\  \aK = \apref[\arole][{}][@][@][.].\aK'  
    & 
    \text{or }\ \aK = \apref[\arole][\arole'][@][\alocvar][.].\aK'
    \\
    &
    \text{or }\ \aK = \apref[\arole].\aK'    
    &
    \text{or }\ \aK = \apref[\arole][\arole'].\aK'  
%    \\
%    \ain[].(\proj[\aK'])
%    &
%    \text{if } \aK = \apref[{}][\arole].\aK'
    \\[10pt]
    \ain[].(\proj[\aK'])
    &
     \text{if }\  \aK = \apref[{}][\arole].\aK' 
     &
     \text{or }\ \aK = \apref[\arole'][\arole].\aK'
    \\[10pt]
    \ard[].(\proj[\aK'])
    &
    \text{if }\  \aK = \apref[{}][\arole][@][@][.].\aK' 
    &
    \text{or }\ \aK = \apref[\arole'][\arole][@][\alocvar][.].\aK'
    \\[10pt]
    \displaystyle{\sum_{i\in I}{\proj[(\apref_i.\aK_i)]}}
    &
     \multicolumn{2}{l}{
     \text{if }\ \aK = \asum[@][@][][]
     }
    \\[10pt]
    \proj[\aK_1]\lseqop \proj[\aK_2] 
    & 
    \multicolumn{2}{l}{
     \text{if }\  \aK = \aK_1 \seqop \aK_2
     }
     \\[10pt]
%    \aout[].(\proj[\aK'])
%    &
%    \text{if } \aK = \apref[\arole][\arole'].\aK'
%    \\
%    \ain[].(\proj[\aK'])
%    &
%    \text{if } \aK = \apref[\arole'][\arole].\aK' \text{ or }
%    \\
%    \arout[].(\proj[\aK'])
%    &
%    \text{if } \aK = \apref[\arole][\arole'][@][\aloc][.].\aK'
%    \\
%    \ard[].(\proj[\aK'])
%    &
%    \text{if } \aK = \apref[\arole'][\arole][@][\aloc][.].\aK'
%    \\
    \multicolumn{3}{l}{
     \alrec [@][x][{
    	\ain[][{\asort[stop]}][x].\nil 
	+ 
	(\ain[][{\nu y:\asort[loc]}][x]. \proj[\aK'][@][\eta,X\mapsto y])}] [\aphi \arole]}
     \\
     &
      \multicolumn{2}{l}{
    \text{if }\ \aK = \grec[\arole'][@][\aK'][\aphi], \ \arole \neq \arole', \text{ and }\ \{x, y\}\cap (\fn{\aK'} \cup \cod \eta) = \emptyset
    }
    \\[10pt]
    \multicolumn{3}{l}{
     \alrec [@][@][{
    	\arout[][{\asort[stop]}][x_1]\ldots\arout[][{\asort[stop]}][x_n].\nil 
	+ 
	\arout[][{\nu y_1:\asort[loc]}][x]\ldots\arout[][{\nu y_n:\asort[loc]}][x]. \proj[\aK'][@][\eta,X\mapsto \seq y]}] [\aphi \arole_1\ldots\aphi \arole_n]}
\\
    &
    \multicolumn{2}{l}{
    \text{if }\ \aK = \grec[\arole'][@][\aK'][\aphi], \dom{\aphi} = \{\rho_1, \ldots, \rho_n\}, \seq x = x_1\ldots x_n,
    }
    \\
    & 
     \multicolumn{2}{l}{
     \seq y = y_1\ldots y_n, \text{ and }  (\seq x\cup \seq y) \cap (\fn{\aK'} \cup \cod \eta) = \emptyset 
      }
     \\[10pt]
      \alvar [@][\eta X]
    & \text{if }\ \aK = X
  \end{array}
  \right.
\]
\caption{Projection}
\label{fig:projection}
\end{figure}
%
We now comment on the definition of $\proj$ in \cref{fig:projection}. 
%
As usual, 
the local type corresponding to a role $\arole$ that is not part of $\aK$  
is $\nil$. 
%
The projection of a prefix $\apref$ depends on the role played by 
$\arole$ in $\apref$: it is omitted when $\arole$ does not participate on $\apref$; it is 
 the production of a tuple when $\apref$ is an interaction
 or an autonomous output and $\rho$ is the producer; it is the consumption of a tuple   
 when $\apref$ is an autonomous input or a consuming interaction and $\rho$ is the consumer;
 or else it is the read of a tuple. 
%
Projection is homomorphic with respect to choices and 
sequential composition. 

 A global type $\grec[@][@][@][\ ]$ is projected as a recursive 
local type $\alrec$ where the formal parameters $\seq x$ stand 
for the locations used for coordination and 
$\seq \alocvar$ are the initial values. 
%
Note that $\grec[@][@][@][\ ]$ does not make explicit the set of 
initial locations but they are so in local types. 
%
For this reason, we
define projection for a decorated version of global types, where 
each recursive sub-term $\grec$ is annotated by a function
$\aphi:\roleset \mapsto \locset$
defined such that $\dom\aphi = \roles\aK\setminus\{\arole\}$ and 
 for all $\arole\in\dom\aphi$,  $\aphi(\arole)$ is globally fresh.
%
Such annotations can be  automatically added by pre-processing  
global types so to associate a fresh set of locations to each recursive
process. 
%
Then, the projection of 
 $\grec[\arole'][@][\aK'][\aphi]$ onto $\arole$ depends on whether $\arole$
 coordinates the recursion  (i.e., $\arole = \arole'$) or not. 
%
When $\rho$ is not 
 the coordinator, the recursive process needs just one location $x$ to await for 
 either $\asort[stop]$ or a new location $y$ for the next iteration.
%
Note 
 that the body of the recursion $\aK'$ is then projecting by considering an extended 
 version of $\eta$ where process variable $X$ is parameterised with the received 
 location $y$. 
%
The initial value of  $x$ is fixed  according to  
 by $\phi$  (i.e., $\phi\arole$). 
%
Differently, when $\arole$ coordinates the recursion, the projection generates 
a process variable that has several parameters, i.e., one location $x_i$ for 
each passive role. 
%
In this case the body of the recursion consists of two 
branches: one that communicates the termination of the recursion to 
each participant, and the other one executes the body of the recursion after
distributing fresh localities to each participants. 
%
Recursion parameters are
initialised analogously. 
%
Finally, a process variable $X$ is projected as its parameterised version 
$\alvar [@][\eta X]$, where the value of parameters are established according 
to $\eta$.


%\begin{example}
%
% This protocol can be formalised by the following global type.
%  \[
%    \begin{array}{l}
%      \ard[\amulti {Seller}][{\atuple[start]}][{\aloc[m]}] \prefop
%      \\
%      \arout[\amulti {Seller}][{{\asort[str]} \cdot {\asort[int]} \cdot {\nu l : \asort[loc]}}][{\aloc[m]}] \prefop
%      \alrec[X][][(\nil + {\arout[\amulti {Seller}][{{\asort[str]} \cdot {\asort[int]} \cdot {\nu l : \asort[loc]}}][{\aloc[m]}]} \prefop X)][]
%      \seqop
%      \\  	
%      \grec[\amulti{Buyer}][Y][{\left({
%      \begin{array}{l}
%        \grec[][Z][{\apref[@][\amulti {Buyer}][{{\asort[str]} \cdot {\asort[int]} \cdot {\asort[loc]}}][{\aloc[m]}][.] \prefop Z}] \seqop
%        \\
%        \apref[@][\amulti {Buyer}][{{i : \asort[str]} \cdot {p : \asort[int]} \cdot {\nu l : \asort[loc]}}][{\aloc[m]}] \prefop
%        \\
%        \grec[\amulti{Seller}][W][\left({
%        \begin{array}{l}
%          \apref[\amulti {Buyer}][\amulti {Seller}][{i : \asort[{str}] \cdot {o : \asort[int]} }][{l}] \prefop
%          \\
%          \qquad 
%          \apref[\amulti {Seller}][\amulti {Buyer}][{\asort[quit]}][{l}] \prefop
%          \\
%          \qquad 
%          \apref[\amulti {Seller}][@][{{i : \asort[str]} \cdot {p : \asort[int]} \cdot {\nu l : \asort[loc]}}][{\aloc[m]}] \prefop
%          \\
%          \qquad
%          Y	
%          \\
%          \qquad
%          \chop
%          \\
%          \qquad 
%          \apref[\amulti {Seller}][\amulti {Buyer}][{\asort[sold]}][{l}]\prefop
%          %	\\
%          %	\qquad \apref[\amulti {Seller}][\ptp {broker}][i :
%          % {\asort[str]} \cdot o : {\asort[int]} ][{\aloc[m]}]\prefop
%          % \\ \qquad
%          Y	
%          \\
%          \qquad
%          \chop
%          \\
%          \qquad
%          \apref[\amulti {Seller}][\amulti {Buyer}][{\asort[more]}][{l}] \prefop W
%          \\
%          \chop
%          \\
%          \apref[\amulti {Buyer}][\amulti {Seller}][{\asort[{noway}]}][{l}] \prefop
%          \\\qquad
%          \apref[\amulti {Seller}][@][{{i : \asort[str]} \cdot {p : \asort[int]} \cdot {\nu l : \asort[loc]}}][{\aloc[m]}] \prefop
%          \\
%          \qquad
%          Y
%        \end{array}
%        }\right)][1]
%      \end{array}
%      }\right)}][1]
%    \end{array}
%  \]
%
%\end{example}

%For recursive terms  $\alrec$, we assume $|\seq x| = |\seq \alocvar|$, 
% variables in $\seq x$ pair-wise different, 
%$\aphi$ injective, $\dom(\aphi) = \roles \aK$, ${\it range}(\aphi) = [0..|\seq x|]$ 
%and $\aphi(\rho) = 0$.
%

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
