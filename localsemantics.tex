% !TEX root =  main.tex
%

Local types $\aL$ have the following syntax
\begin{eqnarray*}
  \aLpref & \bnfdef &
                  \aout[] \bnfmid
                  \arout[]\bnfmid
                  \ain[] \bnfmid
                  \ard[] 
\\
  \aL & \bnfdef &
                  \aLsum \bnfmid
                  X \bnfmid
                  \arec[@][\aL]
\end{eqnarray*}
As for global types, we write $\nil$ for a sum with an empty set $I$ of branches. 

We remark that  $x : \asort$ and $\nu \aloc$ acts as binders for $x$ and $\aloc$. 
We write $\dn\atuple$ for the set of binders of a tuple, defined as follows

The definition of $\fn\_$ is extended to local types 
\begin{eqnarray*}
  \fn {\aout[]}  & = & \fn {\arout[]} = \fn {\ain[]} = \fn {\ard[]} = \fn {\atuple} \cup \{\aloc\}  
  \\
  \fn {\aLsum} & = & \bigcup_{i\in I} \fn{\aLpref_i}\cup (\fn {\aL_i}\setminus \dn{\aLpref_i}) 
  \\
  \fn {X} & = & \emptyset 
  \\
  \fn {\arec[@][\aL]} & = & \fn {\aL} 
\end{eqnarray*}

 
Hereafter we use $v$, $w$ to range over $\varset\cup\locset$. The notion of substitution is extended to local terms.
\begin{align*}
  (\aout[]) \sust v w  = &  \aout[][\atuple\sust v w][(\aloc\sust v w)] &  {\it if}\  \{v,w\}\cap \dn\atuple = \emptyset
  \\ 
  \fn {\arout[]} = & 
  \\
  \fn {\ain[]}  = &
  \\
  \fn {\ard[]}  = &
  \\
  \fn {\aLsum}  = & \bigcup_{i\in I} \fn{\aLpref_i}\cup (\fn {\aL_i}\setminus \dn{\aLpref_i}) 
  \\
  \fn {X}  = & \emptyset 
  \\
  \fn {\arec[@][\aL]}  = & \fn {\aL} 
\end{align*}


Let $s$ and $t$ in $\locset$  local types up-to $\alpha$-renaming of binders. 

%
%For a local type $\aL = \aLsum$, we write $\selectors \aL$ for the selecting roles the choice, i.e.,
%$\selectors \aL = \cup_{i\in I}{\{\arole_i\}}$.
%%
%Moreover, we assume
%\begin{itemize}
%\item $\aL_i \neq\aLsum[j][J]$, for all $i \in I$.
%\item $\arole_i \eqR \arole_j$ for all $i,j \in I$.
%\end{itemize}
%

We consider the following syntax for run-time semantics of a set of local types and tuple spaces, 
called {\em specification}.

\begin{eqnarray*}
  \envmv & \bnfdef & \emptyset \bnfmid
                  \envmv, \arole :  \aL \bnfmid
                  \envmv, \atupleat \bnfmid
                  \envmv, \artupleat                  
\end{eqnarray*}

%In $\arole :  \aL$  we assume
%$\arole \in \participants \cup \multiroles$  and $\arole \eqR \arole'$ for any $\arole'$
%occurring in $\aL$.
%
We write $\envtuple$ for a specification that only contains terms of the form $\atupleat$. 
 
\[
\begin{array}{l@{\hspace{1cm}}l}
\mathrule{}
	{\envmv, \arole : \aout[].\aL 
	 \red[\arole : {\aout[]}]
	 \envmv, \arole : \aL , \atupleat}
	{LOut_1} 
	{\it with}\ 	\dn\atuple\ {\it fresh}
\\[25pt]
\mathrule{}
	{\envmv, \arole : \arout[].\aL 
	 \red[\arole : {\arout[]}]
	 \envmv, \arole : \aL , \artupleat}
	{LOut_2}
	{\it with}\ 	\dn\atuple\ {\it fresh}

\\[25pt]
\mathrule
	{\atuple \matches \atuple' \generates \sigma}
	{\envmv, \arole : \ain[].\aL, \atupleat[][\atuple'] 
	 \red[\arole : {\ain[][\atuple'\sigma]}]
	 \envmv, \arole : \aL\sigma}
	{LIn}
\\[25pt]
\mathrule
	{\atuple \matches \atuple' \generates \sigma}
	{\envmv, \arole : \ard[].\aL, \atupleat[][\atuple'] 
	 \red[\arole : {\ard[][\atuple'\sigma]}]
	 \envmv, \arole : \aL\sigma,  \atupleat[][\atuple'] }
	{LRd_1}
\\[25pt]
\mathrule
	{\atuple \matches \atuple'\generates \sigma}
	{\envmv, \arole : \ard[].\aL, \artupleat[][\atuple'] 
	 \red[\arole : {\ard[][\atuple'\sigma]}]
	 \envmv, \arole : \aL\sigma,  \artupleat[][\atuple'] }
	{LRd_2}
\\[25pt]
\mathrule
	{j\in I \qquad \envtuple, \arole : \aLpref_j.\aL_j \red[\alpha] \envmv'}
	{\envmv, \envtuple, \arole : \aLsum
	 \red[\alpha]
	 \envmv,\envmv'}
	{LSum}
\end{array}
\]

The projection $\proj$ of a global type $\aK$ on a role
$\arole \in \participants \cup \multiroles$ is defined as
\[
  \proj =
  \begin{cases}
    \nil & \text{if } \arole \not \in \roles \aK
    \\
    \displaystyle{\sum_{i\in I}{\proj[(\apref_i.\aK_i)]}}
    &
    \text{if } \aK = \asum
    \\
    \proj[\aK_1]
    &
    \text{if } \aK = \apref.\aK_1 \text{ and } \rho\not\in\roles{\apref}
    \\
    \aout[].(\proj[\aK_1])
    &
    \text{if } \aK = \apref[\arole].\aK_1
    \\
    \arout[].(\proj[\aK_1])
    &
    \text{if } \aK = \apref[\arole][{}][@][@][.].\aK_1
    \\
    \ain[].(\proj[\aK_1])
    &
    \text{if } \aK = \apref[{}][\arole].\aK_1
    \\
    \ard[].(\proj[\aK_1])
    &
    \text{if }  \aK = \apref[{}][\arole][@][@][.].\aK_1
    \\
    \aout[].(\proj[\aK_1])
    &
    \text{if } \aK = \apref[\arole][\arole'].\aK_1
    \\
    \ain[].(\proj[\aK_1])
    &
    \text{if } \aK = \apref[\arole'][\arole].\aK_1
    \\
    \arout[].(\proj[\aK_1])
    &
    \text{if } \aK = \apref[\arole][\arole'][@][\aloc][.].\aK_1
    \\
    \ard[].(\proj[\aK_1])
    &
    \text{if } \aK = \apref[\arole'][\arole][@][\aloc][.].\aK_1
    \\
    X
    & \text{if } \aK = X
    \\
    \arec[@][{(\proj[\aK_1])}]
    &
    \text{if } \aK = \arec[@][\aK_1]
  \end{cases}
\]


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
