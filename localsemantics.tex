% !TEX root =  main.tex
%

A {\em local type} $\aL$, which describes the interaction from the perspective of a single 
role,  is a term generated by the following grammar.
\begin{eqnarray*}
  \aLpref & \bnfdef &
%                  \aout[] \bnfmid
                  \arout[]\bnfmid
                  \ain[] \bnfmid
                  \ard[] 
\\
  \aL & \bnfdef &
                  \aLsum \bnfmid
                  \aL \seqop \aL \bnfmid
                   \alrec \bnfmid
  	        \alvar%[{\alvar[@][x_1,\ldots,x_n]}][\aL]
\end{eqnarray*}
\todo{RB: nella formula sopra compare un carattere strano che mi causa errore di compilazione: l'ho messo tra parentesi, si pu\`o togliere?,
HM: adesso?}

Prefixes $\arout[]$, $\ain[]$ and $\ard[]$ respectively stand for the
production, consumption and read of a tuple $\atuple$ at the locality
$\alocvar$. Differently from global types, local types do not
distinguish the generation of read-only tuples from the ones that can
be consumed.

Formation rules for branching and sequential local types $\aL$ are exactly the same as for 
global types; analogously we write $\nil$ for an empty sum. 
The syntax of recursive local types  deviates from global types to make 
explicit the localities used for coordinating the execution;
consequently, process 
variables are parametric (the syntax for recursive types is borrowed from~\cite{}).
The term $\alrec$ defines a process variable $X$ with parameters $\seq x$ to 
be used in $\aL$; the initial values of $\seq x$ are given by $\seq\alocvar$. Accordingly, 
the usage of a process variable is parameterised, i.e., $\alvar$.  For any $\alrec$, we assume that 
 $|\seq x| = |\seq \alocvar|$ and  $|\seq x| = |\seq {\alocvar'}|$ for any bound occurrence of $\alvar[@][\alocvar']$ in $\aL$.


The notions of free and defined names, well-sorted and closed terms
are straightforwardly extended to local types; in $\alrec$, 
 $X$ and $\seq x$ act as binders for the occurrence in $\aL$.
%
%
%The definition of $\fn\_$ is extended to local types 
%\begin{eqnarray*}
%  \fn {\aout[]}  & = & \fn {\arout[]} = \fn {\ain[]} = \fn {\ard[]} = \fn {\atuple} \cup \{\aloc\}  
%  \\
%  \fn {\aLsum} & = & \bigcup_{i\in I} \fn{\aLpref_i}\cup (\fn {\aL_i}\setminus \dn{\aLpref_i}) 
%  \\
%  \fn {X} & = & \emptyset 
%  \\
%  \fn {\arec[@][\aL]} & = & \fn {\aL} 
%\end{eqnarray*}
%
Substitution on local types is defined as follows. 
\[
\begin{array}{rl@{\hspace{.3cm}}l}
  (\arout[]) \sust x y  = &  \arout[][\atuple\sust x y][(\alocvar\sust x y)] &  {\it if}\  x\not\in\dn\atuple
  \\
  (\ain[]) \sust x y  = &  \ain[][\atuple\sust x y][(\alocvar\sust x y)] &  {\it if}\  x\not\in\dn\atuple
  \\
  (\ard[]) \sust x y  = &  \ard[][\atuple\sust x y][(\alocvar\sust x y)] &  {\it if}\  x\not\in\dn\atuple
%  \\ 
%  \fn {\arout[]} = & 
%  \\
%  \fn {\ain[]}  = &
%  \\
%  \fn {\ard[]}  = &
  \\
   (\aLsum)\sust x y  = & \displaystyle{\sum_{i\in I} {{\aLpref_{i}.\aL_{i}}\sust x y}}
   &  {\it if}\  \forall i. x\not\in\dn{\aLpref_i}
  \\
  (\aL_1\seqop\aL_2)\sust x y  = &  \aL_1\sust x y\seqop  \aL_2\sust x y 
  \\
  \alvar\sust x y  = & \alvar[@][\seq\alocvar\sust x y]  
  \\
  (\alrec[@][\seq z])\sust x y  = & \alrec[@][\seq z][\aL\sust x y][\seq\alocvar\sust x y] &  {\it if}\  \{x,y\}\cap\seq z = \emptyset
\end{array}
\]
%
%
%Let $s$ and $t$ in $\locset$  local types up-to $\alpha$-renaming of binders. 
%
%
%For a local type $\aL = \aLsum$, we write $\selectors \aL$ for the selecting roles the choice, i.e.,
%$\selectors \aL = \cup_{i\in I}{\{\arole_i\}}$.
%%
%Moreover, we assume
%\begin{itemize}
%\item $\aL_i \neq\aLsum[j][J]$, for all $i \in I$.
%\item $\arole_i \eqR \arole_j$ for all $i,j \in I$.
%\end{itemize}
%
As for global types, we consider terms up-to $\alpha$-renaming.
 
We consider the following syntax for the run-time semantics of a set of local types running on a 
tuple space, called {\em specification}.

\begin{eqnarray*}
  \envmv & \bnfdef & \emptyset \bnfmid
                  \envmv, \arole :  \aL \bnfmid
%                  \envmv, \atupleat \bnfmid
                  \envmv, \artupleat                  
\end{eqnarray*}
%
A specification is a multiset containing two kind of pairs:  $\arole :  \aL$   associates a 
role with a local type; while $\artupleat$  indicates that a 
tuple of type $\atuple$ is available at locality $\alocvar$. 
%In $\arole :  \aL$  we assume
%$\arole \in \participants \cup \multiroles$  and $\arole \eqR \arole'$ for any $\arole'$
%occurring in $\aL$.
%
We sometimes write $\envtuple$ to denote a specification containing only
terms of the form $\artupleat$. 

The definition of $\fn{\_}$ is straightforwardly  extended to specifications. 

We give an operational semantics to local types defined inductively by 
the rules in \cref{fig:local-types-sem}, where labels $\alpha$ are of the form 
$\arole : \aLpref$. Rule $\rulename{LOut}$ 
accounts  for the behaviour of a role $\rho$ that  generates a tuple $\atuple$ at the 
locality $\aloc$. The operational semantics for the generation of a tuple $\atuple$ that 
contains binders ensures that  each defined name  is substituted by a fresh free variable 
 (i.e., a variable that does not occur free in $\envmv, \arole : \arout[][@][\aloc].\aL$).
This is achieved by requiring  (i) all bound names in $\atuple$ to be fresh (i.e., $\dn\atuple$  fresh) and 
(ii)  the generated tuple $\eraseB\atuple$ is the binder-free version of $\atuple$. 
Rule $\rulename{LIn}$ handles the case in which a role $\arole$
consumes  a tuple specified as $\atuple$ from locality $\aloc$. In order for the consumption to
take place, the  requested tuple $\atuple$ should match  a tuple $\atuple'$ available 
at the locality $\aloc$. 
Note that the substitution $\sigma$ generated from the match is applied 
to the continuation $\aL$ associated with the role $\arole$; the
consumed tuple is eliminated from the locality $\aloc$. 
%
Rule $\rulename{LRd}$ is analogous to $\rulename{LIn}$, but the 
read tuple is not removed from the tuple space.
%
Rule $\rulename{LSum}$ accounts for a role that follows by choosing one of 
its enabled branches. 
%
The semantics of a recursive term $\alrec$ is given by the rule
 $\rulename{LRec}$, which unfolds the  definition, i.e., $\aL\sust X{\abasiclrec}$
 and substitutes the formal parameters $\seq x$ of the recursive
 definition by the actual parameters $\seq\alocvar$, i.e., it applies
 the substitution $\sust {\seq x}{\seq \alocvar}$.
 

\eMnote{nelle etichette delle conclusioni di Lin e LRd non dovrebbe essere $\atuple$ invece di $\atuple'$?} 
\begin{figure} 
\[
\begin{array}{l@{\hspace{1cm}}l}
%\mathrule{\dn\atuple\ {\it fresh}}
%	{\envmv, \arole : \aout[][@][\aloc].\aL 
%	 \red[\arole : {\aout[][\eraseB\atuple][\aloc]}]
%	 \envmv, \arole : \aL , \atupleat[@][\eraseB\atuple][\aloc]}
%	{LOut_1} 
%\\[25pt]
\mathrule{\dn\atuple\ {\it fresh}}
	{\envmv, \arole : \arout[][@][\aloc].\aL 
	 \red[\arole : {\arout[][\eraseB\atuple][\aloc]}]
	 \envmv, \arole : \aL , \artupleat[@][\eraseB\atuple][\aloc]}
	{LOut}
\\[25pt]
\mathrule
	{\atuple \matches \atuple' \generates \sigma}
	{\envmv, \arole : \ain[][@][\aloc].\aL, \artupleat[][\atuple'][\aloc]
	 \red[\arole : {\ain[][\atuple'][\aloc]}]
	 \envmv, \arole : \aL\sigma}
	{LIn}
\\[25pt]
%\mathrule
%	{\atuple \matches \atuple' \generates \sigma}
%	{\envmv, \arole : \ard[][@][\aloc].\aL, \atupleat[][\atuple'][\aloc] 
%	 \red[\arole : {\ard[][\atuple'\sigma][\aloc]}]
%	 \envmv, \arole : \aL\sigma,  \atupleat[][\atuple'][\aloc] }
%	{LRd_1}
%\\[25pt]
\mathrule
	{\atuple \matches \atuple'\generates \sigma}
	{\envmv, \arole : \ard[][@][\aloc].\aL, \artupleat[][\atuple'][\aloc] 
	 \red[\arole : {\ard[][\atuple'][\aloc]}]
	 \envmv, \arole : \aL\sigma,  \artupleat[][\atuple'][\aloc] }
	{LRd}
\\[25pt]
\mathrule
	{\envtuple, \arole : \aLpref_j.\aL_j \red[\alpha] \envmv'}
	{\envmv, \envtuple, \arole : \aLsum
	 \red[\alpha]
	 \envmv,\envmv'}
	{LSum} \qquad j\in I
\\[25pt]
\mathrule
	{\envmv, \arole : \aL_1  \red[\alpha] \envmv', \arole : \aL'_1 }
	{\envmv, \arole : \aL_1\seqop\aL_2
	 \red[\alpha]
	 \envmv', \arole : \aL'_1\seqop\aL_2}
	{LSeq_1} 
\\[25pt]
\mathrule
	{\envmv, \arole : \aL_1  \red[\alpha] \envmv', \arole : \nil }
	{\envmv, \arole : \aL_1\seqop\aL_2
	 \red[\alpha]
	 \envmv', \arole : \aL_2}
	{LSeq_2} 
\\[25pt]
\mathrule
	{\envmv, \arole : \aL\sust X{\abasiclrec}\sust {\seq x}{\seq \alocvar} \red[\alpha] \envmv'}
	{\envmv, \arole : \alrec \red[\alpha] \envmv'}
	{LRec}
\end{array}
\]
\caption{Semantics of local types}
\label{fig:local-types-sem}
\end{figure}


\subsection{Obtaining local types out of global types}
\eMnote{differenza sulle $\aphi$ globali e locali; fissare}

We know introduce the projection operation that  
obtains the local type of a role from a  global type. 
% 
While the syntax of global types abstracts away from the 
 channels used for  coordinating the execution of 
a recursive global type (i.e., $\grec$), the syntax of 
local types makes them explicit (i.e., $\seq\alocvar$ in $\alrec$). 
In order to fill this gap, we define projection over 
decorated global types that are obtained by annotating
 each recursive term $\grec$  with a function
 $\aphi:\roleset \mapsto \locset$, i.e., $\grec[@][@][@][\aphi]$, 
 defined such that $\dom\aphi = \roles\aK$ and $\forall \arole\in\dom\aphi. \aphi(\arole)\not\in\fn\aK$.
 Note that such annotations can be added straightforwardly by a recursive 
 procedure. Hereafter, we focused on decorated global types. 
 
 The projection of a global type $\aK$ over a role $\arole$ is given by $\proj[@][@][\ ]$. Its formal definition
 relies on an auxiliary parameter $\eta$ that maps process variables into sequences of locations, where 
 $\eta$ keeps track of the locations used for coordination of each recursive variable. Projection $\proj$
is defined as follows.  
 \[
  \proj =\left\{
  \begin{array}{ll}
    \nil & \text{if }\ \arole \not \in \roles \aK
    \\
    \displaystyle{\sum_{i\in I}{\proj[(\apref_i.\aK_i)]}}
    &
    \text{if }\ \aK = \asum[@][@][][]
    \\
    \proj[\aK']
    &
    \text{if }\ \aK = \apref.\aK' \text{ and } \rho\not\in\roles{\apref}
%    \\
%    \aout[].(\proj[\aK'])
%    &
%    \text{if } \aK = \apref[\arole].\aK'
    \\
    \arout[].(\proj[\aK'])
    &
    \text{if }\  \aK = \apref[\arole][{}][@][@][.].\aK' \qquad\quad \text{ or }\ \aK = \apref[\arole].\aK'    \\
    & \text{or } \aK = \apref[\arole][\arole'].\aK'\, \text{ or }\ \aK = \apref[\arole][\arole'][@][\alocvar][.].\aK'
%    \\
%    \ain[].(\proj[\aK'])
%    &
%    \text{if } \aK = \apref[{}][\arole].\aK'
    \\
    \ain[].(\proj[\aK'])
    &
    \text{if }\  \aK = \apref[{}][\arole].\aK' \qquad\ \ \!  \text{or }\ \aK = \apref[\arole'][\arole].\aK'
    \\
    \\
    \ard[].(\proj[\aK'])
    &
    \text{if }\  \aK = \apref[{}][\arole][@][@][.].\aK' \qquad\quad\     \text{or }\ \aK = \apref[\arole'][\arole][@][\alocvar][.].\aK'
    \\
    \proj[\aK_1];\proj[\aK_2] & \text{if }\  \aK = \aK_1 \seqop \aK_2\\
%    \aout[].(\proj[\aK'])
%    &
%    \text{if } \aK = \apref[\arole][\arole'].\aK'
%    \\
%    \ain[].(\proj[\aK'])
%    &
%    \text{if } \aK = \apref[\arole'][\arole].\aK' \text{ or }
%    \\
%    \arout[].(\proj[\aK'])
%    &
%    \text{if } \aK = \apref[\arole][\arole'][@][\aloc][.].\aK'
%    \\
%    \ard[].(\proj[\aK'])
%    &
%    \text{if } \aK = \apref[\arole'][\arole][@][\aloc][.].\aK'
%    \\
    \alvar [@][\eta \rho]
    & \text{if }\ \aK = X
    \\
    \multicolumn{2}{l}{
     \alrec [@][x][{
    	\ain[][{\asort[stop]}][x].\nil 
	+ 
	(\ain[][{\nu y:\asort[loc]}][x]. \proj[\aK'][@][\eta,X\mapsto y])}] [\aphi \arole]}
\\
    &
    \text{if }\ \aK = \arec[@][\aK'][\arole'],  \arole \neq \arole', x \textit{ and }  y \textit{ fresh}, 
     \\
    \multicolumn{2}{l}{
     \alrec [@][@][{
    	\arout[][{\asort[stop]}][x_1]\ldots\arout[][{\asort[stop]}][x_n].\nil 
	+ 
	\arout[][{\nu y_1:\asort[loc]}][x]\ldots\arout[][{\nu y_n:\asort[loc]}][x]. \proj[\aK'][@][\eta,X\mapsto \seq y]}] [\aphi \arole]}
\\
    &
    \text{if }\ \aK = \arec[@][\aK'][\arole], \dom{\aphi} = \{\rho_1, \ldots, \rho_n\}, \seq x = x_1\ldots x_n, \seq y = y_1\ldots y_n,
    \\
    & \textit{ and }  \seq x  \textit{ and } \seq y \textit{ fresh}, 
  \end{array}
  \right.
\]
\eMnote{{farei input di stop e $\nu y_n:\asort[loc]$ non read}}

The projection of prefixes, sums and sequential composition are rather standard; they keep 
write and read actions of the projected role. We just remark that the production of a tuple is 
the same regardless of whether the tuple is intended for consumption or not. 

%For recursive terms  $\alrec$, we assume $|\seq x| = |\seq \alocvar|$, 
% variables in $\seq x$ pair-wise different, 
%$\aphi$ injective, $\dom(\aphi) = \roles \aK$, ${\it range}(\aphi) = [0..|\seq x|]$ 
%and $\aphi(\rho) = 0$.
%

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
