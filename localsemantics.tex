% !TEX root =  main.tex
%

A {\em local type} $\aL$, which describes the interaction from the perspective of a single 
role,  is a term generated by the following grammar.
\begin{eqnarray*}
  \aLpref & \bnfdef &
                  \aout[] \bnfmid
                  \arout[]\bnfmid
                  \ain[] \bnfmid
                  \ard[] 
\\
  \aL & \bnfdef &
                  \aLsum \bnfmid
                  \aL; \aL \bnfmid
                  X \bnfmid
                  \arec[@][\aL]
\end{eqnarray*}


Prefixes $\aLpref$  are analogous to the autonomous prefixes $\apref$ in global types, but 
we elide the identity of the role that performs each action; there are however
 no interaction prefixes since they 
involve more than one role. Formation rules for local types $\aL$ are exactly the same as for 
global types; analogously we write $\nil$ for an empty sum. 

The notions of free and defined names, well-sorted and closed terms are straightforwardly 
extended to local types. As for global types, we consider terms up-to $\alpha$-renaming. 
%
%
%The definition of $\fn\_$ is extended to local types 
%\begin{eqnarray*}
%  \fn {\aout[]}  & = & \fn {\arout[]} = \fn {\ain[]} = \fn {\ard[]} = \fn {\atuple} \cup \{\aloc\}  
%  \\
%  \fn {\aLsum} & = & \bigcup_{i\in I} \fn{\aLpref_i}\cup (\fn {\aL_i}\setminus \dn{\aLpref_i}) 
%  \\
%  \fn {X} & = & \emptyset 
%  \\
%  \fn {\arec[@][\aL]} & = & \fn {\aL} 
%\end{eqnarray*}
%
Substitution on local types is defined as follows. 
\[
\begin{array}{rl@{\hspace{1cm}}l}
  (\aout[]) \sust v w  = &  \aout[][\atuple\sust v w][(\aloc\sust v w)] &  {\it if}\  w\not\in\dn\atuple
  \\
  \multicolumn{3}{c}{\textit{remaining prefixes are defined analogously}}
%  \\ 
%  \fn {\arout[]} = & 
%  \\
%  \fn {\ain[]}  = &
%  \\
%  \fn {\ard[]}  = &
  \\
   (\aLsum)\sust v w  = & \displaystyle{\sum_{i\in I} {{\aLpref_{i}.\aL_{i}}\sust v w}}
   &  {\it if}\  \forall i. w\not\in\dn{\aLpref_i}
  \\
  (\aL_1;\aL_2)\sust v w  = &  \aL_1\sust v w;  \aL_2\sust v w 
  \\
  X\sust v w  = & X 
  \\
  (\arec[@][\aL])\sust v w  = & \arec[@][\aL\sust v w]
\end{array}
\]
%
%
%Let $s$ and $t$ in $\locset$  local types up-to $\alpha$-renaming of binders. 
%
%
%For a local type $\aL = \aLsum$, we write $\selectors \aL$ for the selecting roles the choice, i.e.,
%$\selectors \aL = \cup_{i\in I}{\{\arole_i\}}$.
%%
%Moreover, we assume
%\begin{itemize}
%\item $\aL_i \neq\aLsum[j][J]$, for all $i \in I$.
%\item $\arole_i \eqR \arole_j$ for all $i,j \in I$.
%\end{itemize}
%

We consider the following syntax for the run-time semantics of a set of local types running on a 
tuple space, called {\em specification}.

\begin{eqnarray*}
  \envmv & \bnfdef & \emptyset \bnfmid
                  \envmv, \arole :  \aL \bnfmid
                  \envmv, \atupleat \bnfmid
                  \envmv, \artupleat                  
\end{eqnarray*}
%
A specification is a multiset containing two kind of pairs:  $\arole :  \aL$   associates a 
role with a local type; while $\atupleat$ and $\artupleat$ respectively indicates that a 
tuple of type $\atuple$ is available for being consumed or read  at locality $\alocvar$. 
%In $\arole :  \aL$  we assume
%$\arole \in \participants \cup \multiroles$  and $\arole \eqR \arole'$ for any $\arole'$
%occurring in $\aL$.
%
We sometimes write $\envtuple$ to denote an specification containing only
terms of the form $\atupleat$ or $\artupleat$. 

The definition of $\fn{\_}$ is straightforwardly  extended to specifications. 

We equip  local types with an operational semantics defined inductively by 
the rules in \cref{fig:local-types-sem}. Rules $\rulename{LOut_1}$ and $\rulename{LOut_2}$
account  for the role $\rho$ that respectively generates a tuple $\atuple$ for consumption or reading at 
locality $\aloc$. If a role generates a  $\atuple$ containing a binder, the operational semantics
replaces the binder by a fresh name (i.e., a name that does not occur free in $\envmv, \arole : \aout[][@][\aloc].\aL$).
This is achieved by (i) requiring all bound names in $\atuple$ to be fresh (i.e., $\dn\atuple$  fresh) and 
(ii) generating the tuple $\eraseB\atuple$ instead of $\atuple$, which is the binder-free version of $\atuple$. 
Formally, $\eraseB{\_}$ is defined  such that 
$\eraseB{\nu x:\asort} = x : \asort$,  is the identity on $\asort$ and $x : \asort$ and behaves 
homomorphically over $\cdot$. Rule $\rulename{LIn}$ handles the case in which a role $\arole$
consumes  a tuple specified as $\atuple$ from locality $\aloc$. In order for the consumption to
take place, the  requested tuple $\atuple$ should match with a tuple $\atuple'$ available 
for consumption at locality $\aloc$. 
Note that the substitution $\sigma$ generated by the matching is applied 
to the continuation of $\arole$ and the matching tuple is eliminated from the locality $\aloc$. 
%
Rules $\rulename{LRd_1}$ and $\rulename{LRd_2}$ are analogous to $\rulename{LIn}$, but the 
read tuple is kept in the tuple space.
%
Rule $\rulename{LSum}$ accounts for a role that follows by choosing one of 
its enabled branches. 


 
\begin{figure} 
\[
\begin{array}{l@{\hspace{1cm}}l}
\mathrule{\dn\atuple\ {\it fresh}}
	{\envmv, \arole : \aout[][@][\aloc].\aL 
	 \red[\arole : {\aout[][\eraseB\atuple][\aloc]}]
	 \envmv, \arole : \aL , \atupleat[@][\eraseB\atuple][\aloc]}
	{LOut_1} 
\\[25pt]
\mathrule{\dn\atuple\ {\it fresh}}
	{\envmv, \arole : \arout[][@][\aloc].\aL 
	 \red[\arole : {\arout[][\eraseB\atuple][\aloc]}]
	 \envmv, \arole : \aL , \artupleat[@][\eraseB\atuple][\aloc]}
	{LOut_2}
\\[25pt]
\mathrule
	{\atuple \matches \atuple' \generates \sigma}
	{\envmv, \arole : \ain[][@][\aloc].\aL, \atupleat[][\atuple'][\aloc]
	 \red[\arole : {\ain[][\atuple'\sigma][\aloc]}]
	 \envmv, \arole : \aL\sigma}
	{LIn}
\\[25pt]
\mathrule
	{\atuple \matches \atuple' \generates \sigma}
	{\envmv, \arole : \ard[][@][\aloc].\aL, \atupleat[][\atuple'][\aloc] 
	 \red[\arole : {\ard[][\atuple'\sigma][\aloc]}]
	 \envmv, \arole : \aL\sigma,  \atupleat[][\atuple'][\aloc] }
	{LRd_1}
\\[25pt]
\mathrule
	{\atuple \matches \atuple'\generates \sigma}
	{\envmv, \arole : \ard[][@][\aloc].\aL, \artupleat[][\atuple'][\aloc] 
	 \red[\arole : {\ard[][\atuple'\sigma][\aloc]}]
	 \envmv, \arole : \aL\sigma,  \artupleat[][\atuple'][\aloc] }
	{LRd_2}
\\[25pt]
\mathrule
	{j\in I \qquad \envtuple, \arole : \aLpref_j.\aL_j \red[\alpha] \envmv'}
	{\envmv, \envtuple, \arole : \aLsum
	 \red[\alpha]
	 \envmv,\envmv'}
	{LSum}
\\[25pt]
\mathrule
	{\envmv, \arole : \aL\sust X{\arec[@][\aL]} \red[\alpha] \envmv'}
	{\envmv, \arole : \arec[@][\aL] \red[\alpha] \envmv'}
	{LRec}
\\[25pt]
\mathrule
	{}
	{\envmv, \arole : \arec[@][\aL] \red[\alpha] \envmv, \arole :\nil}
	{LRec???}
\end{array}
\]
\caption{Semantics of local types}
\label{fig:local-types-sem}
\end{figure}


\subsection{Obtaining local types out of global types}
The projection $\proj$ of a global type $\aK$ on a role
$\arole \in \participants \cup \multiroles$ is defined as
\[
  \proj =
  \begin{cases}
    \nil & \text{if } \arole \not \in \roles \aK
    \\
    \displaystyle{\sum_{i\in I}{\proj[(\apref_i.\aK_i)]}}
    &
    \text{if } \aK = \asum
    \\
    \proj[\aK_1]
    &
    \text{if } \aK = \apref.\aK_1 \text{ and } \rho\not\in\roles{\apref}
    \\
    \aout[].(\proj[\aK_1])
    &
    \text{if } \aK = \apref[\arole].\aK_1
    \\
    \arout[].(\proj[\aK_1])
    &
    \text{if } \aK = \apref[\arole][{}][@][@][.].\aK_1
    \\
    \ain[].(\proj[\aK_1])
    &
    \text{if } \aK = \apref[{}][\arole].\aK_1
    \\
    \ard[].(\proj[\aK_1])
    &
    \text{if }  \aK = \apref[{}][\arole][@][@][.].\aK_1
    \\
    \aout[].(\proj[\aK_1])
    &
    \text{if } \aK = \apref[\arole][\arole'].\aK_1
    \\
    \ain[].(\proj[\aK_1])
    &
    \text{if } \aK = \apref[\arole'][\arole].\aK_1
    \\
    \arout[].(\proj[\aK_1])
    &
    \text{if } \aK = \apref[\arole][\arole'][@][\aloc][.].\aK_1
    \\
    \ard[].(\proj[\aK_1])
    &
    \text{if } \aK = \apref[\arole'][\arole][@][\aloc][.].\aK_1
    \\
    X
    & \text{if } \aK = X
    \\
    \arec[@][{(\proj[\aK_1])}]
    &
    \text{if } \aK = \arec[@][\aK_1]
  \end{cases}
\]


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
